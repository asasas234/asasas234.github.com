{"title":"脑裂","uid":"5c47efdc17eed2217ef995cf017168a8","slug":"脑裂","date":"2022-07-03T06:27:45.000Z","updated":"2022-07-03T06:32:13.105Z","comments":true,"path":"api/articles/脑裂.json","keywords":null,"cover":null,"content":"<h2 id=\"背景\"><a href=\"#背景\" class=\"headerlink\" title=\"背景\"></a>背景</h2><p>在具有中央(或领导)服务器的分布式环境中，如果中央服务器死机，系统必须迅速找到替代服务器，否则，系统可能会迅速恶化。</p>\n<p>其中一个问题是，我们不能真正知道领导者是否已经永久停止，或者是否经历了间歇性故障，如停止世界GC暂停或临时网络中断。然而，集群必须继续前进，并挑选一个新的领导者。如果最初的领导人有一个间歇性的失败，我们现在发现自己有一个所谓的僵尸领导人。僵尸领袖可以被定义为被系统认为已经死亡并自那以后重新在线的领袖节点。另一个节点已经取代了它的位置，但僵尸领袖可能还不知道这一点。该系统现在有两个活跃的领导人，他们可能发出相互冲突的命令。系统如何检测这种情况，以便系统中的所有节点都可以忽略来自旧领导者的请求，并且旧领导者本身可以检测到它不再是领导者？</p>\n<h2 id=\"定义\"><a href=\"#定义\" class=\"headerlink\" title=\"定义\"></a>定义</h2><p>分布式系统有两个或更多活动领导者的常见场景称为分裂大脑。<br>分裂大脑是通过使用世代时钟来解决的，世代时钟只是一个单调递增的数字来指示服务器的世代。</p>\n<h2 id=\"解决方案\"><a href=\"#解决方案\" class=\"headerlink\" title=\"解决方案\"></a>解决方案</h2><p>每选出一位新领导人，代号就会递增。这意味着，如果旧领导人的代号是‘1’，那么新领导人的代号就是‘2’。该代号包含在从引导者发送到其他节点的每个请求中。通过这种方式，节点现在可以通过简单地信任具有最高数量的领导者来轻松区分真正的领导者。代号应保存在磁盘上，以便在服务器重新启动后保持可用。一种方法是将其与预写日志中的每个条目一起存储。</p>\n","feature":true,"text":"背景在具有中央(或领导)服务器的分布式环境中，如果中央服务器死机，系统必须迅速找到替代服务器，否则，系统可能会迅速恶化。 其中一个问题是，我们不能真正知道领导者是否已经永久停止，或者是否经历了间歇性故障，如停止世界GC暂停或临时网络中断。然而，集群必须继续前进，并挑选一个新的领导...","link":"","photos":[],"count_time":{"symbolsCount":576,"symbolsTime":"1 mins."},"categories":[],"tags":[{"name":"系统设计模式","slug":"系统设计模式","count":5,"path":"api/tags/系统设计模式.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E8%83%8C%E6%99%AF\"><span class=\"toc-text\">背景</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%AE%9A%E4%B9%89\"><span class=\"toc-text\">定义</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88\"><span class=\"toc-text\">解决方案</span></a></li></ol>","author":{"name":"李志博的博客","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"分享Java、中间件 等技术与学习笔记。","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}},"mapped":true,"prev_post":{},"next_post":{"title":"故障检测","uid":"9254c5dd5c94857ab7eacd672f6ed06b","slug":"故障检测","date":"2022-07-03T06:24:41.000Z","updated":"2022-07-03T06:26:44.693Z","comments":true,"path":"api/articles/故障检测.json","keywords":null,"cover":null,"text":"背景在分布式系统中，准确地检测故障是一个很难解决的问题，因为我们不能100%肯定地说系统是否真的停机了，或者只是由于高负载、网络拥塞等原因导致响应非常慢。传统的故障检测机制，如心跳，会输出布尔值，告诉我们系统是否还活着；没有中间立场。心跳使用固定的超时，如果没有来自服务器的心跳，...","link":"","photos":[],"count_time":{"symbolsCount":523,"symbolsTime":"1 mins."},"categories":[],"tags":[{"name":"系统设计模式","slug":"系统设计模式","count":5,"path":"api/tags/系统设计模式.json"}],"author":{"name":"李志博的博客","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"分享Java、中间件 等技术与学习笔记。","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}},"feature":true}}