{"title":"重新设计数据索引结构,缓存内存从2.3G降到了59MB","uid":"82b321e71a818dfcf2a53be9140d17a7","slug":"重新设计数据索引结构-缓存内存从2-3G降到了59MB","date":"2022-06-18T03:22:34.000Z","updated":"2022-06-18T07:52:13.740Z","comments":true,"path":"api/articles/重新设计数据索引结构-缓存内存从2-3G降到了59MB.json","keywords":null,"cover":[],"content":"<h2 id=\"背景\"><a href=\"#背景\" class=\"headerlink\" title=\"背景\"></a>背景</h2><p>之前写过的<a href=\"%E6%96%87%E4%BB%B6%E7%BC%93%E5%AD%98%E7%9A%84%E8%AE%BE%E8%AE%A1\">文件缓存的设计</a>，后来我发现还是有很多缺点的，比如说</p>\n<ol>\n<li>实际索引结构内存占用也不小，而且只有hash索引和entity列索引，那么其他搜索场景，可能依然点需要通过顺序遍历的方式</li>\n<li>另外搜索命中entity列索引的ID列表，有可能会分散在各个ID和offset映射的区间，为了读到数据，最终还是要把所有文件区间都读到内存，失去了内存优化的意义，并且性能会很慢，平时IO读一次要100多ms，但是有时候偶尔会有一次1秒以上的情况（单次读）。</li>\n</ol>\n<h2 id=\"效果介绍\"><a href=\"#效果介绍\" class=\"headerlink\" title=\"效果介绍\"></a>效果介绍</h2><p>于是我设计了新的索引结构，新的结构支持任何搜索条件都可以命中索引，并且不在需要文件IO，纯内存存储，内存占用特别小（原始数据不算索引,大小是2.3G,结构是<code>List&lt;Map&lt;String,Object&gt;&gt;</code> ，新的索引占用内存大小是59MB）,以下是新老内存占用效果对比。</p>\n<img src=\"../img/image-20220618132709867.png\" alt=\"image-20220618132709867\" style=\"zoom:50%;\" />\n\n<p>以上是纯原始数据要占用2.3G，<code>MyList</code> 是我临时写的1个数据包装类，目的是为了方便在Jprofiler看内存大小。以下是MyList类的样子。</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">@Data\n  private static class MyList &#123;\n      private final List&lt;Map&lt;String, Object&gt;&gt; maps;\n  &#125;</code></pre>\n\n<p>下面是新的索引结构占用内存效果，所有索引以及索引相关的一些元数据都存储在<code>CubeDataCacheMetaData</code> 这个类里，可以看到它最终占用内存大小是59MB</p>\n<img src=\"../img/image-20220618132916924.png\" alt=\"image-20220618132916924\" style=\"zoom:50%;\" />\n\n<h2 id=\"新索引的设计\"><a href=\"#新索引的设计\" class=\"headerlink\" title=\"新索引的设计\"></a>新索引的设计</h2><img src=\"../img/image-20220618133729978.png\" alt=\"image-20220618133729978\" style=\"zoom:50%;\" />\n\n<p>以上的图是新索引的图形化表示，每个列映射列下去重后的值（因为存的都是维度值，所以去重后不会有太多），每个值映射的是拥有这个数据的ID范围，这里为了节省内存，只存1个范围，也就是2个数字，起始值和结束值。为了便于理解，可以把上图所表示的索引结构想象成下面这样，实际为了进一步优化，会有稍微的不同:</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">Map&lt;String,Map&lt;String,List&lt;Range&lt;Integer&gt;&gt;&gt;&gt;</code></pre>\n\n<p>Range类是Guava的1个类，表示1个范围，里面可以存储lowerBound(起始值)和upperBound(结束值)2个范围，并且它自带的<code>intersection</code>方法求交集也正是我们所需要的。</p>\n<p>那么有了这个索引结构，假设说，我要搜索的2个条件是列1 &#x3D; 去重后的值1，列2等于去重后的值B，因为是map结构，所以我可以很快速的找到2个条件所表示的ID范围</p>\n<table>\n<thead>\n<tr>\n<th>列1 （去重后的值1）</th>\n<th>列2（去重后的值B）</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>1-120</td>\n<td>1-49</td>\n</tr>\n<tr>\n<td>178-190</td>\n<td>81-100</td>\n</tr>\n</tbody></table>\n<p>有了这几个ID范围，那么列1的范围和列2的范围最终我去做1个交集，其实就是最终我们要搜索的ID集合结果了，这个例子的结果就是2个ID范围，1-49和81-100。</p>\n<p>以上算不同条件的ID的交集，有很多提高搜索速度方便的优化点 ：</p>\n<ol>\n<li>在搜索之前，我会按每个搜索条件得到的ID范围再次进行排序</li>\n<li>然后对按每个列得到的搜索范围列表的大小进行排序，小的范围在前，类似于驱动表的意思。</li>\n<li>接下来，我遍历排序后第一个条件的范围列表，拿到每一个范围，跟后续条件的范围列表不断比较去算他们的交集，由于范围之前是有序的，在算交集之前和过程中，还会做如下处理<ol>\n<li>如果2个范围翻墙不相交，直接return</li>\n<li>如果第一个范围在后面条件的范围集合的第5个范围里发现是存在交集的，那么算第2个范围时，可以直接从第5个范围的基础上开始算，不用每次从头开始，因为范围是有序的。</li>\n</ol>\n</li>\n</ol>\n<p>通过ID算交集这种数字比较的方式，去替代以前不命中索引，或者只命中1个entity索引后，其他列扔需要循环顺序字符串equals比较的方式，极大的提高了搜索速度。</p>\n<p>现在得到了ID，但是我们最终要向上返回的仍然是List&lt;Map&lt;String,Object&gt;&gt;的结构，之前说不在需要文件IO的方式，是因为我们可以通过ID到前面图里说的索引结构里反向查出来ID对应的每个列的值是多少，从而现去组装出我们的数据。</p>\n<p>在这里，也有2个优化：</p>\n<ol>\n<li>如果搜索条件就1个值，那压根不需要去索引结构里查，既然命中了这个ID，那么值一定是这个。</li>\n<li>由于每个值映射的ID范围都是有序的，所以可以通过二分搜索的方式，实现快速定位。</li>\n</ol>\n<p>最后还有1点要说的是，其实真实的存储结构，并不是前面说的</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">Map&lt;String,Map&lt;String,List&lt;Range&lt;Integer&gt;&gt;&gt;&gt;</code></pre>\n\n<p>而是</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">Map&lt;String,Map&lt;String,LongArrayList&gt;&gt;</code></pre>\n\n<p>LongArrayList 是<code>eclipse-collection</code> 的类，看名字就可以知道，它是1个存储long类型的List，并且它存储的是基本类型的<code>long</code> 不存在装箱的问题。</p>\n<p>而用<code>long</code>去替代Range主要是考虑1个<code>long</code>是64位恰好可以利用低32位去存1个int,高32位去存1个，因为整个公司所有项目，最大的事实表也就6000多万，所以int类型表示其中1个ID绝对是足够的，这样用<code>long</code>去替代Range<Integer>，也就避免了装箱和Java引用类型对象算占用的内存空间浪费。</p>\n<h2 id=\"Hash索引的内存优化\"><a href=\"#Hash索引的内存优化\" class=\"headerlink\" title=\"Hash索引的内存优化\"></a>Hash索引的内存优化</h2><p>在老版本里Hash索引的结构大概如下</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">IntObjectHashMap&lt;IntArrayList&gt;</code></pre>\n\n<p>以上也是<code>eclipse-collections</code>里的类，为了便于理解，也可以想象成</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">Map&lt;Integer,List&lt;Integer&gt;&gt;</code></pre>\n\n<p>之所以这存是因为虽然绝大多数Map里的Key也就是Hash值和ID也就是Value的关系是一对一映射的，但是Hash是存在冲突的，所以我们用了1个List来存储。</p>\n<p>但是上述结构之前设计不好的地方是，毕竟绝大多数的数据其实是Hash不冲突的，但是为此却额外创建了1个List,导致了内存的浪费。</p>\n<p>新的结构我在原有的结构基础上增加了1个</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">IntIntHashMap</code></pre>\n\n<p>我们可以理解成:</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">Map&lt;Integer,Integer&gt;</code></pre>\n\n<p>这样默认Hash的索引存在这里，如果真的发生了Hash冲突，在升级到原有的结构里，避免创建额外的List浪费内存。</p>\n<h2 id=\"值列表存储的优化\"><a href=\"#值列表存储的优化\" class=\"headerlink\" title=\"值列表存储的优化\"></a>值列表存储的优化</h2><p>之前事实表里的关于值的列，其实有2列大概如下</p>\n<table>\n<thead>\n<tr>\n<th>decimal_val</th>\n<th>string_val</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>190000</td>\n<td>null</td>\n</tr>\n<tr>\n<td>-52932.410000</td>\n<td>null</td>\n</tr>\n<tr>\n<td>…</td>\n<td>…</td>\n</tr>\n</tbody></table>\n<p>一般来讲，绝大多数Case用的其实都是decimal_val列，少数可能会只用string_val 列，或者string_val 和 decimal_val 混用的情况。</p>\n<p>之前版本我的存储结构大概如下:</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">List&lt;CubeDataValue&gt; list;</code></pre>\n\n<p><code>CubeDataValue</code> 里有2个属性1个decimalValue,1个stringValue ，这样来实现以上3种可能的不同使用情况。</p>\n<p>但是上面的这种设计，对于绝大多数只使用decimal_val的场景来说，就是一种浪费，所以新的存储方案，我用1个思维导图来表示如下:</p>\n<img src=\"../img/image-20220618142613491.png\" alt=\"image-20220618142613491\" style=\"zoom:50%;\" />\n\n<p>通过这样1个对象，3种不同的实现，来兼容3种不同的情况，对于绝大多数场景来讲，就是纯Double类型的实现，里面也就是1个<code>DoubleArrayList</code>里存的是基本类型的<code>double</code>值</p>\n<p>纯String类型的实现比较简单，就是普通的<code>List&lt;String&gt;</code>, 如果是混合类型实现，我将数据也是分double和string 2块分开来存的，这么做的原因也是为了避免装箱浪费内存。但是这么做以后，当数据要进行查找的时候，就没办法通过ID定位具体的数据，所以就有了后面2个结构。</p>\n<p>先说下<code>LongArrayList</code> ，这个存储的long是用来记录位操作，如果是<code>String</code>的值，那么在对应id - 1 的位上，设置1，否则就是0，那么当根据ID来查找时候，就可以知道对应的数据是1个字符串还是1个数字，从而知道去哪查。像我测试的这个Case来讲，1个long可以记录64条数据，117w的数据用18000多个long就可以存下了。</p>\n<p>但是光知道去哪查还不够，还需要知道查找的index,所以还需要1个IntIntHashMap存储的就是ID和实际集合Index的映射关系。</p>\n<p>以上的思路，适用于虽然是混合类型，但是数字类型的值占绝大多数的情况，如果是字符串占绝大多数的话，感觉反而不太好，算是这次设计不太好的地方。</p>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><p>经过这次的优化，我觉得要想内存占用的少，以后可以多往如下几个点去思考:</p>\n<ol>\n<li>优化存储结构，尽量避免数据在内存中发生重复</li>\n<li>能存范围的数据，不要存真实的值</li>\n<li>尽可能避免基本类型的装箱，尽量用基本类型去存储。</li>\n<li>多思考位操作，比如说用1个long存储2个Int 这种方式来减少数据的存储。</li>\n</ol>\n","feature":true,"text":"背景之前写过的文件缓存的设计，后来我发现还是有很多缺点的，比如说 实际索引结构内存占用也不小，而且只有hash索引和entity列索引，那么其他搜索场景，可能依然点需要通过顺序遍历的方式 另外搜索命中entity列索引的ID列表，有可能会分散在各个ID和offset映射的区间，为...","link":"","photos":[],"count_time":{"symbolsCount":"3.7k","symbolsTime":"3 mins."},"categories":[],"tags":[{"name":"Java","slug":"Java","count":5,"path":"api/tags/Java.json"},{"name":"工作","slug":"工作","count":2,"path":"api/tags/工作.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E8%83%8C%E6%99%AF\"><span class=\"toc-text\">背景</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E6%95%88%E6%9E%9C%E4%BB%8B%E7%BB%8D\"><span class=\"toc-text\">效果介绍</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E6%96%B0%E7%B4%A2%E5%BC%95%E7%9A%84%E8%AE%BE%E8%AE%A1\"><span class=\"toc-text\">新索引的设计</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#Hash%E7%B4%A2%E5%BC%95%E7%9A%84%E5%86%85%E5%AD%98%E4%BC%98%E5%8C%96\"><span class=\"toc-text\">Hash索引的内存优化</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%80%BC%E5%88%97%E8%A1%A8%E5%AD%98%E5%82%A8%E7%9A%84%E4%BC%98%E5%8C%96\"><span class=\"toc-text\">值列表存储的优化</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E6%80%BB%E7%BB%93\"><span class=\"toc-text\">总结</span></a></li></ol>","author":{"name":"李志博的博客","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"分享Java、中间件 等技术与学习笔记。","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}},"mapped":true,"prev_post":{"title":"BloomFilters","uid":"1d4e4cde9c655456c3b6951c0ffa8502","slug":"BloomFilters","date":"2022-06-19T01:28:08.000Z","updated":"2022-06-19T03:05:08.210Z","comments":true,"path":"api/articles/BloomFilters.json","keywords":null,"cover":[],"text":"背景如果我们在一组数据文件中存储了大量结构化数据(由记录ID标识)，那么知道哪个文件可能包含我们需要的数据的最有效方法是什么？我们不想读取每个文件，因为这样会很慢，而且我们必须从磁盘读取大量数据。一种解决方案是在每个数据文件上建立索引，并将其存储在单独的索引文件中。每个索引文件将...","link":"","photos":[],"count_time":{"symbolsCount":936,"symbolsTime":"1 mins."},"categories":[],"tags":[{"name":"系统设计模式","slug":"系统设计模式","count":2,"path":"api/tags/系统设计模式.json"}],"author":{"name":"李志博的博客","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"分享Java、中间件 等技术与学习笔记。","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}},"feature":true},"next_post":{"title":"BigDecimal类的四个常见陷阱以及如何避免它们","uid":"2e752d116822fcd8f3fa0fbea2092f6c","slug":"BigDecimal类的四个常见陷阱以及如何避免它们","date":"2022-06-11T02:14:48.000Z","updated":"2022-06-17T08:24:03.804Z","comments":true,"path":"api/articles/BigDecimal类的四个常见陷阱以及如何避免它们.json","keywords":null,"cover":null,"text":"在Java中进行货币计算时，您可以使用java.math.BigDecimal–但要注意该类的一些独特挑战。 在使用Java进行商业计算时，尤其是对于货币，最好使用该类来避免与浮点算术相关的问题，如果使用两个基元类型之一：Float或Double(或它们的盒装类型对应类型)，则可...","link":"","photos":[],"count_time":{"symbolsCount":"4k","symbolsTime":"4 mins."},"categories":[],"tags":[{"name":"Java","slug":"Java","count":5,"path":"api/tags/Java.json"}],"author":{"name":"李志博的博客","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"分享Java、中间件 等技术与学习笔记。","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}}}