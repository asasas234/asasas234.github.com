{"title":"BloomFilters","uid":"1d4e4cde9c655456c3b6951c0ffa8502","slug":"BloomFilters","date":"2022-06-19T01:28:08.000Z","updated":"2022-06-19T03:05:08.210Z","comments":true,"path":"api/articles/BloomFilters.json","keywords":null,"cover":[],"content":"<h2 id=\"背景\"><a href=\"#背景\" class=\"headerlink\" title=\"背景\"></a>背景</h2><p>如果我们在一组数据文件中存储了大量结构化数据(由记录ID标识)，那么知道哪个文件可能包含我们需要的数据的最有效方法是什么？我们不想读取每个文件，因为这样会很慢，而且我们必须从磁盘读取大量数据。一种解决方案是在每个数据文件上建立索引，并将其存储在单独的索引文件中。每个索引文件将根据记录ID进行排序。现在，如果我们想要在此索引中搜索ID，最好的方法是二进制搜索。我们还能做得更好吗？</p>\n<h2 id=\"定义\"><a href=\"#定义\" class=\"headerlink\" title=\"定义\"></a>定义</h2><p>使用Bloom Filters快速查找某个元素是否可能出现在集合中。</p>\n<h2 id=\"解决方案\"><a href=\"#解决方案\" class=\"headerlink\" title=\"解决方案\"></a>解决方案</h2><p>Bloom Filter数据结构告诉我们元素是否可能在集合中，或者肯定不在集合中。唯一可能的错误是误报，即搜索不存在的元素可能会给出错误的答案。过滤器中的元素越多，错误率就越高。空的布隆过滤器是由m个比特组成的比特数组，全部设置为0。还有k个不同的hash函数，每个hash函数将集合元素哈希到m个比特位置之一。</p>\n<ul>\n<li>要添加一个元素，将其提供给哈希函数以获得k个位位置，并将这些位置处的位设置为1。</li>\n<li>要测试元素是否在集合中，请将其提供给哈希函数以获得k个位位置。<ul>\n<li>如果这些位置的任一位为0，则该元素肯定不在该集合中。</li>\n<li>如果全部为1，则元素可能在集合中。</li>\n</ul>\n</li>\n</ul>\n<p>下面是一个包含三个元素P、Q和R的Bloom过滤器。它由20位组成，使用三个散列函数。彩色箭头指向集合的元素映射到的位。</p>\n<img src=\"../img/image-20220619105051382.png\" alt=\"image-20220619105051382\" style=\"zoom:50%;\" />\n\n<ul>\n<li>元素X肯定不在集合中，因为它散列到包含0的位位置。</li>\n<li>对于固定的错误率，添加新元素和测试成员资格都是恒定的时间操作，而具有‘n’个元素空间的过滤器需要O(N)<br>O(N)空间。</li>\n</ul>\n<h2 id=\"示例：Bigtable\"><a href=\"#示例：Bigtable\" class=\"headerlink\" title=\"示例：Bigtable\"></a>示例：Bigtable</h2><p>在Bigtable(和Cassandra)中，任何读取操作都必须从 Tablet组成的SSTables中读取。如果这些SSTable不在内存中，读操作可能会发起多次磁盘访问。为了减少磁盘访问次数，Bigtable使用了Bloom Filters。</p>\n<p>Bloom Filters是为SSTables(特别是为局部性组)创建的。它们通过预测SSTable是否可能包含对应于特定行或列对的数据来帮助减少磁盘访问次数。对于某些应用程序，用于存储Bloom过滤器的少量Tablet服务器内存可显著减少磁盘寻道次数，从而提高读取性能。</p>\n","feature":true,"text":"背景如果我们在一组数据文件中存储了大量结构化数据(由记录ID标识)，那么知道哪个文件可能包含我们需要的数据的最有效方法是什么？我们不想读取每个文件，因为这样会很慢，而且我们必须从磁盘读取大量数据。一种解决方案是在每个数据文件上建立索引，并将其存储在单独的索引文件中。每个索引文件将...","link":"","photos":[],"count_time":{"symbolsCount":936,"symbolsTime":"1 mins."},"categories":[],"tags":[{"name":"系统设计模式","slug":"系统设计模式","count":2,"path":"api/tags/系统设计模式.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E8%83%8C%E6%99%AF\"><span class=\"toc-text\">背景</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%AE%9A%E4%B9%89\"><span class=\"toc-text\">定义</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88\"><span class=\"toc-text\">解决方案</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E7%A4%BA%E4%BE%8B%EF%BC%9ABigtable\"><span class=\"toc-text\">示例：Bigtable</span></a></li></ol>","author":{"name":"李志博的博客","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"分享Java、中间件 等技术与学习笔记。","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}},"mapped":true,"prev_post":{"title":"一致性Hash","uid":"02d29d69da92d1495f7e9b3c258ba0cc","slug":"一致性Hash","date":"2022-06-19T03:15:56.000Z","updated":"2022-06-19T13:44:46.114Z","comments":true,"path":"api/articles/一致性Hash.json","keywords":null,"cover":[],"text":"背景跨一组节点分发数据的行为称为数据分区。当我们尝试分发数据时，有两个挑战： 我们如何知道特定数据将存储在哪个节点上？ 当我们添加或删除节点时，我们如何知道哪些数据将从现有节点移动到新节点？此外，当节点加入或离开时，我们如何最大限度地减少数据移动？ 一种简单的方法将使用适当的ha...","link":"","photos":[],"count_time":{"symbolsCount":"2k","symbolsTime":"2 mins."},"categories":[],"tags":[{"name":"系统设计模式","slug":"系统设计模式","count":2,"path":"api/tags/系统设计模式.json"}],"author":{"name":"李志博的博客","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"分享Java、中间件 等技术与学习笔记。","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}},"feature":true},"next_post":{"title":"重新设计数据索引结构,缓存内存从2.3G降到了59MB","uid":"82b321e71a818dfcf2a53be9140d17a7","slug":"重新设计数据索引结构-缓存内存从2-3G降到了59MB","date":"2022-06-18T03:22:34.000Z","updated":"2022-06-18T07:52:13.740Z","comments":true,"path":"api/articles/重新设计数据索引结构-缓存内存从2-3G降到了59MB.json","keywords":null,"cover":[],"text":"背景之前写过的文件缓存的设计，后来我发现还是有很多缺点的，比如说 实际索引结构内存占用也不小，而且只有hash索引和entity列索引，那么其他搜索场景，可能依然点需要通过顺序遍历的方式 另外搜索命中entity列索引的ID列表，有可能会分散在各个ID和offset映射的区间，为...","link":"","photos":[],"count_time":{"symbolsCount":"3.7k","symbolsTime":"3 mins."},"categories":[],"tags":[{"name":"Java","slug":"Java","count":5,"path":"api/tags/Java.json"},{"name":"工作","slug":"工作","count":2,"path":"api/tags/工作.json"}],"author":{"name":"李志博的博客","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"分享Java、中间件 等技术与学习笔记。","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}}}