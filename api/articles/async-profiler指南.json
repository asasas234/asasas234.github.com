{"title":"async-profiler指南","uid":"db45217419a12dfdde75d94a88900ee9","slug":"async-profiler指南","date":"2022-09-18T02:13:39.000Z","updated":"2022-09-18T03:32:47.520Z","comments":true,"path":"api/articles/async-profiler指南.json","keywords":null,"cover":[],"content":"<h2 id=\"1-概述\"><a href=\"#1-概述\" class=\"headerlink\" title=\"1. 概述\"></a>1. 概述</h2><p><a href=\"https://www.baeldung.com/java-profilers\">Java Sampling Profilers</a>  通常使用JVM工具接口(JVMTI)进行设计，并在安全点收集堆栈跟踪。因此，这些采样剖析器可能会受到<a href=\"https://psy-lob-saw.blogspot.com/2016/02/why-most-sampling-java-profilers-are.html\">安全点偏差问题</a>的影响。</p>\n<p>对于应用程序的整体视图，我们需要一个采样分析器，它不需要线程位于安全点，并且可以随时收集堆栈跟踪，以避免安全点偏差问题。</p>\n<p>在本教程中，我们将探索<a href=\"https://github.com/jvm-profiling-tools/async-profiler\"><em>async-profiler</em></a> 以及它提供的各种分析技术。</p>\n<h2 id=\"2-async-profiler\"><a href=\"#2-async-profiler\" class=\"headerlink\" title=\"2. async-profiler\"></a>2. async-profiler</h2><p>async-profiler是一个适用于任何基于HotSpot JVM的JDK的采样分析器。它的开销很低，并且不依赖JVMTI。</p>\n<p>它通过使用HotSpot JVM提供的AsyncGetCallTrace API来分析Java代码路径，并使用Linux的perf_Events来分析本机代码路径，从而避免了安全点偏差问题。</p>\n<p>换句话说，分析器匹配Java代码和本机代码路径的调用堆栈以生成准确的结果。</p>\n<h2 id=\"3-设置\"><a href=\"#3-设置\" class=\"headerlink\" title=\"3. 设置\"></a>3. 设置</h2><h3 id=\"3-1-安装\"><a href=\"#3-1-安装\" class=\"headerlink\" title=\"3.1 安装\"></a>3.1 安装</h3><p>首先，我们将下载基于我们平台的最新版本的<a href=\"https://github.com/jvm-profiling-tools/async-profiler/releases\"><em>async-profiler</em></a>。目前，它只支持Linux和MacOS平台。</p>\n<p>下载后，我们可以检查它是否在我们的平台上工作：</p>\n<pre class=\"line-numbers language-sh\" data-language=\"sh\"><code class=\"language-sh\">.&#x2F;profiler.sh --version</code></pre>\n\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">Async-profiler 1.7.1 built on May 14 2020\nCopyright 2016-2020 Andrei Pangin</code></pre>\n\n<p>事先检查async-profiler可用的所有选项总是一个好主意：</p>\n<pre class=\"line-numbers language-sh\" data-language=\"sh\"><code class=\"language-sh\">.&#x2F;profiler.sh</code></pre>\n\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">Usage: .&#x2F;profiler.sh [action] [options] \nActions:\n  start             start profiling and return immediately\n  resume            resume profiling without resetting collected data\n  stop              stop profiling\n  check             check if the specified profiling event is available\n  status            print profiling status\n  list              list profiling events supported by the target JVM\n  collect           collect profile for the specified period of time\n                    and then stop (default action)\nOptions:\n  -e event          profiling event: cpu|alloc|lock|cache-misses etc.\n  -d duration       run profiling for  seconds\n  -f filename       dump output to \n  -i interval       sampling interval in nanoseconds\n  -j jstackdepth    maximum Java stack depth\n  -b bufsize        frame buffer size\n  -t                profile different threads separately\n  -s                simple class names instead of FQN\n  -g                print method signatures\n  -a                annotate Java method names\n  -o fmt            output format: summary|traces|flat|collapsed|svg|tree|jfr\n  -I include        output only stack traces containing the specified pattern\n  -X exclude        exclude stack traces with the specified pattern\n  -v, --version     display version string\n\n  --title string    SVG title\n  --width px        SVG width\n  --height px       SVG frame height\n  --minwidth px     skip frames smaller than px\n  --reverse         generate stack-reversed FlameGraph &#x2F; Call tree\n\n  --all-kernel      only include kernel-mode events\n  --all-user        only include user-mode events\n  --cstack mode     how to traverse C stack: fp|lbr|no\n\n is a numeric process ID of the target JVM\n      or &#39;jps&#39; keyword to find running JVM automatically</code></pre>\n\n<p>所显示的许多选项将在后面的小节中派上用场。</p>\n<h3 id=\"3-2-内核配置\"><a href=\"#3-2-内核配置\" class=\"headerlink\" title=\"3.2. 内核配置\"></a>3.2. 内核配置</h3><p>在Linux平台上使用async-profiler时，我们应该确保将内核配置为由所有用户使用perf_Events捕获调用堆栈：</p>\n<p>首先，我们将PERF_EVENT_PARANOID设置为1，这将允许分析器收集性能信息：</p>\n<pre class=\"line-numbers language-sh\" data-language=\"sh\"><code class=\"language-sh\">sudo sh -c &#39;echo 1 &gt;&#x2F;proc&#x2F;sys&#x2F;kernel&#x2F;perf_event_paranoid&#39;</code></pre>\n\n<p>然后，我们将kptr_restraint设置为0，以取消对公开内核地址的限制：</p>\n<pre class=\"line-numbers language-sh\" data-language=\"sh\"><code class=\"language-sh\">sudo sh -c &#39;echo 0 &gt;&#x2F;proc&#x2F;sys&#x2F;kernel&#x2F;kptr_restrict&#39;</code></pre>\n\n<p>然而，<em>async-profiler</em>将在MacOS平台上独立工作。</p>\n<p>现在我们的平台已经准备好了，我们可以构建性能分析应用程序并使用Java命令运行它：</p>\n<pre class=\"line-numbers language-sh\" data-language=\"sh\"><code class=\"language-sh\">java -XX:+UnlockDiagnosticVMOptions -XX:+DebugNonSafepoints -jar path-to-jar-file</code></pre>\n\n<p>在这里，我们已经使用***<a href=\"https://www.baeldung.com/jvm-tuning-flags#1-diagnostic-flags\">-XX:+UnlockDiagnosticVMOptions</a> -XX:+DebugNonSafepoints*** JVM标志启动了我们的分析应用程序，强烈建议使用这些标志以获得准确的结果。</p>\n<p>现在我们已经准备好分析我们的应用程序，让我们来探索<em>async-profiler</em>支持的各种类型的分析。</p>\n<h2 id=\"4-CPU-Profiling\"><a href=\"#4-CPU-Profiling\" class=\"headerlink\" title=\"4. CPU Profiling\"></a>4. CPU Profiling</h2><p>Async-Profiler在分析CPU时收集Java方法的样例堆栈跟踪，包括JVM代码、本机类和内核函数。</p>\n<p>让我们使用PID来分析我们的应用程序：</p>\n<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\">$ .&#x2F;profiler.sh -e cpu -d 30 -o summary 66959\nStarted [cpu] profiling\n--- Execution profile --- \nTotal samples       : 28\n\nFrame buffer usage  : 0.069%</code></pre>\n\n<p>在这里，我们使用-e选项定义了CPU性能分析事件。然后，我们使用-d&lt;持续时间&gt;选项收集样本，持续30秒。</p>\n<p>最后，-o选项对于定义摘要、HTML、TRACE、SVG和TREE等输出格式很有用。</p>\n<p>让我们在CPU分析应用程序的同时创建HTML输出：</p>\n<p><img src=\"/../img/image-20220918112146989.png\" alt=\"image-20220918112146989\"></p>\n<p>在这里，我们可以看到允许我们展开、折叠和搜索示例的HTML输出。</p>\n<p>此外，Async-Profiler支持开箱即用的火焰图表。</p>\n<p>让我们使用应用程序的CPU配置文件的.svg文件扩展名来生成火焰图：</p>\n<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\">.&#x2F;profiler.sh -e cpu -d 30 -f cpu_profile.svg 66959</code></pre>\n\n<p><img src=\"/../img/image-20220918112259618.png\" alt=\"image-20220918112259618\"></p>\n<p>在这里，生成的火焰图用绿色显示Java代码路径，用黄色显示C++，用红色显示系统代码路径。</p>\n<h2 id=\"5-分配分析\"><a href=\"#5-分配分析\" class=\"headerlink\" title=\"5.分配分析\"></a>5.分配分析</h2><p>类似地，我们可以收集内存分配的样本，而无需使用像字节码插装这样的侵入性技术。</p>\n<p>Async-Profiler使用基于TLAB(线程本地分配缓冲区)的采样技术来收集TLAB平均大小以上的堆分配样本。</p>\n<p>通过使用alloc事件，我们可以使性能分析器收集性能分析应用程序的堆分配：</p>\n<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\">.&#x2F;profiler.sh-e allc-d 30-f allc_profile.svg 66255</code></pre>\n\n<p><img src=\"/../img/image-20220918112816769.png\" alt=\"image-20220918112816769\"></p>\n<p>这里，我们可以看到对象克隆分配了很大一部分内存，否则在查看代码时很难察觉到这一点。</p>\n<h2 id=\"6-Wall-Clock-Profiling\"><a href=\"#6-Wall-Clock-Profiling\" class=\"headerlink\" title=\"6. Wall-Clock Profiling\"></a>6. Wall-Clock Profiling</h2><p>此外，通过使用wall-clock配置文件，异步分析器可以对所有线程进行采样，而不考虑它们的状态–如运行、睡眠或阻塞。</p>\n<p>在应用程序启动时对问题进行故障排除时，这可能会很方便。</p>\n<p>通过定义WALL事件，我们可以配置分析器来收集所有线程的样本：</p>\n<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\">.&#x2F;profiler.sh -e wall -t -d 30 -f wall_clock_profile.svg 66959</code></pre>\n\n<p><img src=\"/../img/image-20220918113158920.png\" alt=\"image-20220918113158920\"></p>\n<p>在这里，我们通过使用-t选项在每个线程模式下使用了挂钟分析器，这是在分析所有线程时强烈建议使用的选项。</p>\n<p>此外，我们还可以使用List选项检查JVM支持的所有性能分析事件：</p>\n<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\">.&#x2F;profiler.sh list 66959</code></pre>\n\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">Basic events:\n  cpu\n  alloc\n  lock\n  wall\n  itimer\nJava method calls:\n  ClassName.methodName</code></pre>\n\n","text":"1. 概述Java Sampling Profilers 通常使用JVM工具接口(JVMTI)进行设计，并在安全点收集堆栈跟踪。因此，这些采样剖析器可能会受到安全点偏差问题的影响。 对于应用程序的整体视图，我们需要一个采样分析器，它不需要线程位于安全点，并且可以随时收集堆栈跟踪，...","link":"","photos":[],"count_time":{"symbolsCount":"4.4k","symbolsTime":"4 mins."},"categories":[],"tags":[{"name":"JVM","slug":"JVM","count":2,"path":"api/tags/JVM.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#1-%E6%A6%82%E8%BF%B0\"><span class=\"toc-text\">1. 概述</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#2-async-profiler\"><span class=\"toc-text\">2. async-profiler</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#3-%E8%AE%BE%E7%BD%AE\"><span class=\"toc-text\">3. 设置</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#3-1-%E5%AE%89%E8%A3%85\"><span class=\"toc-text\">3.1 安装</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#3-2-%E5%86%85%E6%A0%B8%E9%85%8D%E7%BD%AE\"><span class=\"toc-text\">3.2. 内核配置</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#4-CPU-Profiling\"><span class=\"toc-text\">4. CPU Profiling</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#5-%E5%88%86%E9%85%8D%E5%88%86%E6%9E%90\"><span class=\"toc-text\">5.分配分析</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#6-Wall-Clock-Profiling\"><span class=\"toc-text\">6. Wall-Clock Profiling</span></a></li></ol>","author":{"name":"李志博的博客","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"分享Java、中间件 等技术与学习笔记。","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}},"mapped":true,"prev_post":{"title":"介绍红黑树","uid":"d7ce011fd2434eab0f67698b6d1bed31","slug":"介绍红黑树","date":"2022-09-24T07:31:24.000Z","updated":"2022-09-25T01:39:20.722Z","comments":true,"path":"api/articles/介绍红黑树.json","keywords":null,"cover":[],"text":"1. 介绍在本文中，我们将了解什么是红黑树，以及为什么它们是如此流行的数据结构。 我们将从查看二叉搜索树和2-3棵树开始。从这里，我们将看到红黑树如何被认为是平衡2-3树的不同代表。 本文的目的是以一种简单的方式解释红黑树，因此我们不会深入研究所有可能的插入和删除情况的代码示例或...","link":"","photos":[],"count_time":{"symbolsCount":"3.9k","symbolsTime":"4 mins."},"categories":[],"tags":[{"name":"算法","slug":"算法","count":1,"path":"api/tags/算法.json"}],"author":{"name":"李志博的博客","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"分享Java、中间件 等技术与学习笔记。","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}},"next_post":{"title":"MySQL快速导入数据","uid":"a6af7b290f5171db5db2fabe49e62533","slug":"MySQL快速导入数据","date":"2022-07-22T07:30:59.000Z","updated":"2022-07-22T07:56:17.659Z","comments":true,"path":"api/articles/MySQL快速导入数据.json","keywords":null,"cover":null,"text":"由于公司内网到测试环境网速太慢，所以当导大批量数据的时候，如果直接通过本地GUI工具去导入，速度会很慢，这个时候可以直接登录到测试环境MYSQL的服务器上，通过命令进行导入就会很快，因为省去了数据文件传输的步骤（运维提前帮忙传好） LOAD DATA LOCAL INFILE &...","link":"","photos":[],"count_time":{"symbolsCount":465,"symbolsTime":"1 mins."},"categories":[],"tags":[{"name":"mysql","slug":"mysql","count":2,"path":"api/tags/mysql.json"}],"author":{"name":"李志博的博客","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"分享Java、中间件 等技术与学习笔记。","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}}}