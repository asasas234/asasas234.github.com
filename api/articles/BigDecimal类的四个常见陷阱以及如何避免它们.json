{"title":"BigDecimal类的四个常见陷阱以及如何避免它们","uid":"2e752d116822fcd8f3fa0fbea2092f6c","slug":"BigDecimal类的四个常见陷阱以及如何避免它们","date":"2022-06-11T02:14:48.000Z","updated":"2022-06-13T03:32:53.272Z","comments":true,"path":"api/articles/BigDecimal类的四个常见陷阱以及如何避免它们.json","keywords":null,"cover":null,"content":"<p><strong>在Java中进行货币计算时，您可以使用java.math.BigDecimal–但要注意该类的一些独特挑战。</strong></p>\n<p>在使用Java进行商业计算时，尤其是对于货币，最好使用该类来避免与浮点算术相关的问题，如果使用两个基元类型之一：Float或Double(或它们的盒装类型对应类型)，则可能会遇到这些问题。</p>\n<p>事实上，该类包含许多方法，可以满足大多数常见业务计算的要求。</p>\n<p>然而，我想提请大家注意BigDecimal类的四个常见陷阱。当您使用常规的BigDecimal API和使用一个新的、可扩展的定制类时，可以避免它们。</p>\n<p>那么，让我们从常规的 BigDecimal API 开始。</p>\n<h2 id=\"陷阱1-双重构造函数\"><a href=\"#陷阱1-双重构造函数\" class=\"headerlink\" title=\"陷阱1: 双重构造函数\"></a>陷阱1: 双重构造函数</h2><p>考虑下面的例子:</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">BigDecimal x &#x3D; new BigDecimal(0.1);\nSystem.out.println(&quot;x&#x3D;&quot; + x);</code></pre>\n\n<p>下面是控制台的输出:</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">x&#x3D;0.1000000000000000055511151231257827021181583404541015625</code></pre>\n\n<p>如您所见，此构造函数的结果可能有些不可预测。这是因为浮点数在计算机硬件中表示为基数2(二进制)小数。但是，大多数小数不能完全表示为二进制小数。因此，机器中实际存储的二进制浮点数仅接近您输入的十进制浮点数。因此，传递给Double构造函数的值不完全等于0.1。</p>\n<p>相反，字符串构造函数是完全可预测的，并且生成的值恰好等于0.1，不出所料。</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">BigDecimal y &#x3D; new BigDecimal(&quot;0.1&quot;);\nSystem.out.println(&quot;y&#x3D;&quot; + y);</code></pre>\n\n<p>现在，控制台输出如下：</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">y&#x3D;0.1</code></pre>\n\n<p>因此，您应该优先使用字符串构造函数，而不是Double构造函数。</p>\n<h2 id=\"陷阱2-静态ValueOf方法\"><a href=\"#陷阱2-静态ValueOf方法\" class=\"headerlink\" title=\"陷阱2: 静态ValueOf方法\"></a>陷阱2: 静态ValueOf方法</h2><p>如果使用静态<code>BigDecimal.valueOf(Double)</code>方法创建<code>BigDecimal</code>，请注意其精度有限。</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">BigDecimal x &#x3D; BigDecimal.valueOf(1.01234567890123456789);\nBigDecimal y &#x3D; new BigDecimal(&quot;1.01234567890123456789&quot;);\nSystem.out.println(&quot;x&#x3D;&quot; + x);\nSystem.out.println(&quot;y&#x3D;&quot; + y);</code></pre>\n\n<p>上面的代码生成以下控制台输出：</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">x&#x3D;1.0123456789012346\ny&#x3D;1.01234567890123456789</code></pre>\n\n<p>在这里，该值丢失了四位小数位，因为Double的精度只有15-17位(Float的精度只有6-9位)，而BigDecimal的精度是任意的(仅受内存限制)。</p>\n<p>因此，使用字符串构造函数实际上是一个好主意，因为有效地避免了由双重构造函数引起的两个主要问题。</p>\n<h2 id=\"陷阱-3：Equals-BigDecimal-方法\"><a href=\"#陷阱-3：Equals-BigDecimal-方法\" class=\"headerlink\" title=\"陷阱#3：Equals(BigDecimal)方法\"></a>陷阱#3：Equals(BigDecimal)方法</h2><pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">BigDecimal x &#x3D; new BigDecimal(&quot;1&quot;);\nBigDecimal y &#x3D; new BigDecimal(&quot;1.0&quot;);\nSystem.out.println(x.equals(y));</code></pre>\n\n<p>控制台输出如下：</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">False</code></pre>\n\n<p>此输出是由于BigDecimal由任意精度的未缩放整数值和32位整数小数位数组成，这两个值都必须等于要比较的另一个BigDecimal的相应值。在这种情况下</p>\n<ul>\n<li>X的未缩放值为1，比例为0。</li>\n<li>Y的未缩放值为10，比例为1。</li>\n</ul>\n<p>因此，X不等于Y。</p>\n<p>因此，不应该使用equals()方法比较BigDecimal的两个实例，而应该使用CompareTo()方法，因为它比较了BigDecimal的两个实例表示的数值(x&#x3D;1；y&#x3D;1.0)。下面是一个例子：</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">System.out.println(x.compareTo(y) &#x3D;&#x3D; 0);</code></pre>\n\n<p>现在，控制台输出如下：</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">True</code></pre>\n\n<h2 id=\"陷阱-4：round-MathContext-方法\"><a href=\"#陷阱-4：round-MathContext-方法\" class=\"headerlink\" title=\"陷阱#4：round(MathContext)方法\"></a>陷阱#4：round(MathContext)方法</h2><p>一些开发人员可能会倾向于使用<code>round(new MathContext(precision, roundingMode))</code>方法将BigDecimal舍入为(比方说)两位小数。这不是个好主意。</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">BigDecimal x &#x3D; new BigDecimal(&quot;12345.6789&quot;);\nx &#x3D; x.round(new MathContext(2, RoundingMode.HALF_UP));\nSystem.out.println(&quot;x&#x3D;&quot; + x.toPlainString());\nSystem.out.println(&quot;scale&#x3D;&quot; + x.scale());</code></pre>\n\n<p>上面的代码生成以下控制台输出，因此x不是12345.68的预期值，刻度也不是2的预期值：</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">x&#x3D;12000 \nscale&#x3D;-3</code></pre>\n\n<p>该方法不会对小数部分进行舍入，但会将未按比例调整的值舍入到给定的有效位数(从左到右计数)，小数点保持不变，在上面的示例中，小数点的小数位数为-3。</p>\n<p>那么，这里发生了什么？</p>\n<p>未缩放值(123456789)被四舍五入为两位有效数字(12)，这表示精度为2。但是，由于小数点保持不变，因此此BigDecimal表示的实际值为12000.0000。这也可以写为12000，因为小数点右侧的四个零没有意义。</p>\n<p>但规模又如何呢？为什么它是-3而不是0，正如您对值12000的预期？</p>\n<p>这是因为这个BigDecimal的无标度值是12，因此，它必须乘以1000，这是10的3次方，(12x103)等于12000。</p>\n<p>因此，正小数位数表示小数位数(即小数点右侧的位数)，而负数位数表示小数点左侧的无用位数(在本例中是尾随的零，因为它们只是指示数字小数位数的占位符)。</p>\n<p>最后，由BigDecimal表示的数字因此是unscaledValue x 10刻度。</p>\n<p>还要注意，上面的代码使用了toPlainString()方法，该方法不以科学记数法(1.2E+4)显示结果。</p>\n<p>若要获得12345.68的预期结果，请尝试使用setScale(Scale，oundingMode)方法，例如：</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">BigDecimal x &#x3D; new BigDecimal(&quot;12345.6789&quot;);\nx &#x3D; x.setScale(2, RoundingMode.HALF_UP);\nSystem.out.println(&quot;x&#x3D;&quot; + x));</code></pre>\n\n<p>现在控制台输出的就是预期的结果。</p>\n<p>现在，控制台输出是预期的：</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">x&#x3D;12345.68</code></pre>\n\n<p>方法的作用是：根据指定的舍入模式将小数部分舍入到小数点后两位。</p>\n<p>顺便说一句，您可以使用ROUND(new MathContext(Precision，oundingMode))方法进行传统的舍入。但这需要您知道计算结果小数点左侧的总位数。请考虑以下示例：</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">BigDecimal a &#x3D; new BigDecimal(&quot;12345.12345&quot;);\nBigDecimal b &#x3D; new BigDecimal(&quot;23456.23456&quot;);\nBigDecimal c &#x3D; a.multiply(b);\nSystem.out.println(&quot;c&#x3D;&quot; + c);</code></pre>\n\n<p>现在，控制台输出如下：</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">c&#x3D;289570111.3153564320</code></pre>\n\n<p>要将c舍入到小数点后两位，您必须使用精度为11的MathContext对象，例如：</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">BigDecimal d &#x3D; c.round(new MathContext(11, RoundingMode.HALF_UP));\nSystem.out.println(&quot;d&#x3D;&quot; + d);</code></pre>\n\n<p>上面的代码生成以下控制台输出：</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">d&#x3D;289570111.32</code></pre>\n\n<p>小数点左侧的总位数可按如下方式计算：</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">bigDecimal.precision() - bigDecimal.scale() + newScale</code></pre>\n\n<ul>\n<li><code>bigDecimal.precision()</code> 是未四舍五入的总长度。</li>\n<li><code>bigDecimal.scale()</code> 是未四舍五入小数的长度。</li>\n<li><code>newScale</code> 是您指定的新的小数部分长度。</li>\n</ul>\n<p>所以，下面代码:</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">BigDecimal e &#x3D; c.round(new MathContext(c.precision() - c.scale() + 2, RoundingMode.HALF_UP));</code></pre>\n\n<p>控制台输出</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">e&#x3D;289570111.32</code></pre>\n\n<p>然而，如果你将这个表达式</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">c.round(new MathContext(c.precision() - c.scale() + 2, RoundingMode.HALF_UP));</code></pre>\n\n<p>设置为以下表达式</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">c.setScale(2, RoundingMode.HALF_UP);</code></pre>\n\n<p>很明显，您会选择哪一个来确保代码的可读性和简明性。</p>\n","feature":true,"text":"在Java中进行货币计算时，您可以使用java.math.BigDecimal–但要注意该类的一些独特挑战。 在使用Java进行商业计算时，尤其是对于货币，最好使用该类来避免与浮点算术相关的问题，如果使用两个基元类型之一：Float或Double(或它们的盒装类型对应类型)，则可...","link":"","photos":[],"count_time":{"symbolsCount":"4k","symbolsTime":"4 mins."},"categories":[],"tags":[{"name":"Java","slug":"Java","count":4,"path":"api/tags/Java.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E9%99%B7%E9%98%B11-%E5%8F%8C%E9%87%8D%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0\"><span class=\"toc-text\">陷阱1: 双重构造函数</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E9%99%B7%E9%98%B12-%E9%9D%99%E6%80%81ValueOf%E6%96%B9%E6%B3%95\"><span class=\"toc-text\">陷阱2: 静态ValueOf方法</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E9%99%B7%E9%98%B1-3%EF%BC%9AEquals-BigDecimal-%E6%96%B9%E6%B3%95\"><span class=\"toc-text\">陷阱#3：Equals(BigDecimal)方法</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E9%99%B7%E9%98%B1-4%EF%BC%9Around-MathContext-%E6%96%B9%E6%B3%95\"><span class=\"toc-text\">陷阱#4：round(MathContext)方法</span></a></li></ol>","author":{"name":"李志博的博客","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"分享Java、中间件 等技术与学习笔记。","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}},"mapped":true,"prev_post":{},"next_post":{"title":"SpringBoot单测通过注解覆盖Spring配置","uid":"725e856f26b6befd144f449656c3dc6b","slug":"SpringBoot单测通过注解覆盖Spring配置","date":"2022-06-05T06:58:09.000Z","updated":"2022-06-05T07:06:20.584Z","comments":true,"path":"api/articles/SpringBoot单测通过注解覆盖Spring配置.json","keywords":null,"cover":null,"text":"在我们写SpringBoot的单测的时候,有时候可能需要指定特殊的配置,用来覆盖原有的配置，以前的做法通常是2种 在IDEA的RUN&#x2F;DEBUG Configurations 弹窗上设置-D启动参数 在单测上人工写1个static 代码块，然后里面写System.set...","link":"","photos":[],"count_time":{"symbolsCount":"1.1k","symbolsTime":"1 mins."},"categories":[],"tags":[{"name":"SpringBoot","slug":"SpringBoot","count":2,"path":"api/tags/SpringBoot.json"}],"author":{"name":"李志博的博客","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"分享Java、中间件 等技术与学习笔记。","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}},"feature":true}}