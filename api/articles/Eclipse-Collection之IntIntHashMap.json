{"title":"Eclipse-Collection之IntIntHashMap","uid":"e939d2a67c854d9584266b38aea34ab3","slug":"Eclipse-Collection之IntIntHashMap","date":"2022-05-23T14:09:07.000Z","updated":"2022-05-23T14:21:20.966Z","comments":true,"path":"api/articles/Eclipse-Collection之IntIntHashMap.json","keywords":null,"cover":[],"content":"<p>最近在设计1个功能，其中需要内存保存数据的全量索引，结构大概如下:</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">Map&lt;Integer,Integer&gt; indexMap &#x3D; new HashMap&lt;&gt;();</code></pre>\n\n<p>我跑单测观察这个Map占用内存的时候发现，110多万的数据要消耗500多MB内存，这个其实对内存的占用已经算是非常大了，那么就可以用标题说的Eclipse-Collection库的IntIntHashMap来替代之前的HashMap</p>\n<p>首先我们引包:</p>\n<pre class=\"line-numbers language-markup\" data-language=\"markup\"><code class=\"language-markup\">&lt;dependency&gt;\n        &lt;groupId&gt;org.eclipse.collections&lt;&#x2F;groupId&gt;\n        &lt;artifactId&gt;eclipse-collections-api&lt;&#x2F;artifactId&gt;\n        &lt;version&gt;11.0.0&lt;&#x2F;version&gt;\n    &lt;&#x2F;dependency&gt;\n\n    &lt;dependency&gt;\n        &lt;groupId&gt;org.eclipse.collections&lt;&#x2F;groupId&gt;\n        &lt;artifactId&gt;eclipse-collections&lt;&#x2F;artifactId&gt;\n        &lt;version&gt;11.0.0&lt;&#x2F;version&gt;\n    &lt;&#x2F;dependency&gt;</code></pre>\n\n<p>然后IntIntHashMap的使用和普通Map区别不大，只不过由于确定了Key和Value都是Int，所以就不需要泛型了</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">@Test\nvoid printObjectSize2() throws InterruptedException &#123;\n    Thread.sleep(1000 * 60);\n    System.out.println(&quot;begin&quot;);\n    IntIntHashMap intHashMap &#x3D; new IntIntHashMap();\n    for (int i &#x3D; 0; i &lt; 1000000; i++) &#123;\n        intHashMap.put(i, i);\n    &#125;\n    System.out.println(&quot;end&quot;);\n    Thread.currentThread().join();\n&#125;</code></pre>\n\n<p>执行上面的单测，begin前面的sleep是为了预留登录arthas的时间，然后通过执行<code>memory</code>观察当前堆内存大小。</p>\n<p><img src=\"/../img/image-20220523222052564.png\" alt=\"image-20220523222052564\"></p>\n<p>然后执行到end的时候，在执行一次<code>memory</code>看下堆的大小，发现这次只占用61MB。</p>\n<p><img src=\"/../img/image-20220523222106711.png\" alt=\"image-20220523222106711\"></p>\n","text":"最近在设计1个功能，其中需要内存保存数据的全量索引，结构大概如下: Map&lt;Integer,Integer&gt; indexMap &#x3D; new HashMap&lt;&gt;(); 我跑单测观察这个Map占用内存的时候发现，110多万的数据要消耗500多MB内存...","link":"","photos":[],"count_time":{"symbolsCount":"1.3k","symbolsTime":"1 mins."},"categories":[],"tags":[{"name":"Java","slug":"Java","count":5,"path":"api/tags/Java.json"},{"name":"Eclipse-Collection","slug":"Eclipse-Collection","count":1,"path":"api/tags/Eclipse-Collection.json"}],"toc":"","author":{"name":"李志博的博客","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"分享Java、中间件 等技术与学习笔记。","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}},"mapped":true,"prev_post":{"title":"Mockito跟SpringBoot@Autowired组合使用方式","uid":"9f14b7d15ba15e4a4bdd3158410a83f4","slug":"Mockito跟SpringBoot-Autowired组合使用方式","date":"2022-06-04T06:10:53.000Z","updated":"2022-06-05T01:52:56.700Z","comments":true,"path":"api/articles/Mockito跟SpringBoot-Autowired组合使用方式.json","keywords":null,"cover":null,"text":"有的时候，我们想绝大多数Bean在单测的时候，还是希望走正常的Bean注入,只有少部分Bean需要自己人工Mock结果，这个时候如何优雅的Mock Bean实例并自动和其他Bean实例一样进行注入呢？ 可以通过Mockito的@MockBean注解解决，代码如下 @SpringB...","link":"","photos":[],"count_time":{"symbolsCount":396,"symbolsTime":"1 mins."},"categories":[],"tags":[{"name":"mockito","slug":"mockito","count":1,"path":"api/tags/mockito.json"},{"name":"SpringBoot","slug":"SpringBoot","count":2,"path":"api/tags/SpringBoot.json"}],"author":{"name":"李志博的博客","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"分享Java、中间件 等技术与学习笔记。","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}},"next_post":{"title":"native内存最佳实践","uid":"f929186e789271318e9dfdac1fb85b07","slug":"native内存最佳实践","date":"2022-05-21T01:43:03.000Z","updated":"2022-05-21T08:57:15.547Z","comments":true,"path":"api/articles/native内存最佳实践.json","keywords":null,"cover":[],"text":"堆是Java应用程序中最大的内存消耗者，但JVM将分配和使用大量本机内存。虽然第7章从编程的角度讨论了有效管理堆的方法，但堆的配置以及它如何与操作系统的本机内存交互是影响应用程序整体性能的另一个重要因素。这里存在术语冲突，因为C程序员倾向于将其本机内存的一部分称为C堆。为了与以J...","link":"","photos":[],"count_time":{"symbolsCount":"15k","symbolsTime":"14 mins."},"categories":[],"tags":[{"name":"Java","slug":"Java","count":5,"path":"api/tags/Java.json"},{"name":"JVM","slug":"JVM","count":1,"path":"api/tags/JVM.json"}],"author":{"name":"李志博的博客","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"分享Java、中间件 等技术与学习笔记。","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}}}