{"title":"一致性Hash","uid":"02d29d69da92d1495f7e9b3c258ba0cc","slug":"一致性Hash","date":"2022-06-19T03:15:56.000Z","updated":"2022-06-19T13:44:46.114Z","comments":true,"path":"api/articles/一致性Hash.json","keywords":null,"cover":[],"content":"<h2 id=\"背景\"><a href=\"#背景\" class=\"headerlink\" title=\"背景\"></a>背景</h2><p>跨一组节点分发数据的行为称为数据分区。当我们尝试分发数据时，有两个挑战：</p>\n<ol>\n<li>我们如何知道特定数据将存储在哪个节点上？</li>\n<li>当我们添加或删除节点时，我们如何知道哪些数据将从现有节点移动到新节点？此外，当节点加入或离开时，我们如何最大限度地减少数据移动？</li>\n</ol>\n<p>一种简单的方法将使用适当的hash函数，将数据键映射到一个数字。然后，通过对此数量和服务器总数求模来找到服务器。例如：</p>\n<img src=\"../img/image-20220619183740871.png\" alt=\"image-20220619183740871\" style=\"zoom:50%;\" />\n\n<p>上图中描述的方案解决了寻找用于存储&#x2F;检索数据的服务器的问题。但当我们添加或删除服务器时，我们必须重新映射所有键，并根据新的服务器计数移动数据，这将是一个完全混乱的过程！</p>\n<h2 id=\"定义\"><a href=\"#定义\" class=\"headerlink\" title=\"定义\"></a>定义</h2><p>使用一致的hash算法跨节点分发数据。一致的hash将数据映射到物理节点，并确保在添加或删除服务器时只移动一小部分key。</p>\n<h2 id=\"解决\"><a href=\"#解决\" class=\"headerlink\" title=\"解决\"></a>解决</h2><p>一致hash技术将分布式系统管理的数据存储在环中。环中的每个节点都被分配了一系列数据。以下是一致hash环的一个示例：</p>\n<img src=\"../img/image-20220619184856077.png\" alt=\"image-20220619184856077\" style=\"zoom:50%;\" />\n\n<p>使用一致性Hash，可以将环划分为较小的预定义范围。每个节点都被分配到这些范围中的一个。范围的开始称为令牌。这意味着将为每个节点分配一个令牌。分配给每个节点的范围计算如下：</p>\n<p>范围开始：一个令牌值<br>范围结束：下一个令牌值-1</p>\n<p>以下是上图中描述的四个节点的令牌和数据范围</p>\n<table>\n<thead>\n<tr>\n<th>Server</th>\n<th>Token</th>\n<th>Range Start</th>\n<th>Range End</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Server 1</td>\n<td>1</td>\n<td>1</td>\n<td>25</td>\n</tr>\n<tr>\n<td>Server 2</td>\n<td>26</td>\n<td>26</td>\n<td>50</td>\n</tr>\n<tr>\n<td>Server 3</td>\n<td>51</td>\n<td>51</td>\n<td>75</td>\n</tr>\n<tr>\n<td>Server 4</td>\n<td>76</td>\n<td>76</td>\n<td>100</td>\n</tr>\n</tbody></table>\n<p>每当系统需要读取或写入数据时，它执行的第一步是将MD5Hash算法应用于Key。该Hash算法的输出确定数据位于哪个范围内，从而确定数据将存储在哪个节点上。正如我们在上面看到的，每个节点都应该存储固定范围的数据。因此，从Key生成的Hash告诉我们将在其中存储数据的节点。</p>\n<img src=\"../img/image-20220619185333043.png\" alt=\"image-20220619185333043\" style=\"zoom:50%;\" />\n\n<p>当向环中添加节点或从环中移除节点时，如上所述的一致性Hash方案工作得很好，因为只有下一个节点受到影响。例如，当一个节点被移除时，下一个节点将负责存储在移除节点上的所有Key。然而，这种方案可能会导致数据和负载分布不均匀。这个问题可以通过虚拟节点来解决。</p>\n<h2 id=\"虚拟节点\"><a href=\"#虚拟节点\" class=\"headerlink\" title=\"虚拟节点\"></a>虚拟节点</h2><p>在任何分布式系统中添加和删除节点都很常见。现有节点可能会死亡，可能需要停用。同样，可以将新节点添加到现有群集中以满足不断增长的需求。为了有效地处理这些场景，一致hash使用虚拟节点(或虚拟节点)。</p>\n<p>正如我们在上面看到的，基本一致Hash算法为每个物理节点分配单个令牌(或连续的Hash范围)。这是一种静态范围划分，需要根据给定的节点数量计算令牌。此方案使添加或替换节点成为一项代价高昂的操作，因为在本例中，我们希望重新平衡数据并将其分发到所有其他节点，从而导致移动大量数据。以下是与手动和固定范围划分相关的一些潜在问题：</p>\n<ul>\n<li>添加或删除节点：添加或删除节点将导致重新计算令牌，从而为大型集群带来巨大的管理开销。</li>\n<li>热点：由于每个节点都被分配了一个大范围，如果数据分布不均匀，一些节点可能会成为热点。</li>\n<li>节点重建：由于每个节点的数据可能被复制到固定数量的其他节点上(以实现容错)，因此当我们需要重建节点时，只有其副本节点可以提供数据。这给副本节点带来了很大的压力，并可能导致服务降级。</li>\n</ul>\n<p>为了处理这些问题，一致性Hash引入了一种将令牌分发到物理节点的新方案。不是将单个令牌分配给节点，而是将哈希范围划分为多个较小的范围，并为每个物理节点分配多个这些较小的范围。这些子范围中的每一个都被视为Vnode。对于VNodes，一个节点不是只负责一个令牌，而是负责许多令牌(或子范围)。</p>\n<img src=\"../img/image-20220619212426871.png\" alt=\"image-20220619212426871\" style=\"zoom:50%;\" />\n\n<p>实际上，虚拟节点在整个集群中随机分布，并且通常不连续，因此不会将两个相邻的虚拟节点分配给相同的物理节点或机架。此外，节点确实携带其他节点的副本以实现容错。此外，由于群集中可能存在异类计算机，因此某些服务器可能会比其他服务器包含更多的Vnode。下图显示了物理节点A、B、C、D和E如何使用一致哈希环的V节点。每个物理节点都被分配了一组Vnode，并且每个Vnode被复制一次。</p>\n<img src=\"../img/image-20220619213044888.png\" alt=\"image-20220619213044888\" style=\"zoom:50%;\" />\n\n<h2 id=\"虚拟节点的优势\"><a href=\"#虚拟节点的优势\" class=\"headerlink\" title=\"虚拟节点的优势\"></a>虚拟节点的优势</h2><ol>\n<li>由于虚拟节点通过将哈希范围划分为更小的子范围来帮助在群集上的物理节点上更均匀地分配负载，因此在添加或删除节点后加快了重新平衡过程。当添加新节点时，它会从现有节点接收许多Vnode，以维护平衡的集群。同样，当一个节点需要重建时，许多节点都会参与重建过程，而不是从固定数量的副本获取数据。</li>\n<li>虚拟节点使维护包含异类机器的集群变得更容易。这意味着，使用VNodes，我们可以将大量的子范围分配给功能强大的服务器，将较少数量的子范围分配给功能较弱的服务器。</li>\n<li>与一个大范围相比，由于V节点帮助为每个物理节点分配较小的范围，这降低了出现热点的可能性。</li>\n</ol>\n<h2 id=\"例子\"><a href=\"#例子\" class=\"headerlink\" title=\"例子\"></a>例子</h2><p>Dynamo和Cassandra使用一致性Hash来跨节点分发数据。</p>\n","feature":true,"text":"背景跨一组节点分发数据的行为称为数据分区。当我们尝试分发数据时，有两个挑战： 我们如何知道特定数据将存储在哪个节点上？ 当我们添加或删除节点时，我们如何知道哪些数据将从现有节点移动到新节点？此外，当节点加入或离开时，我们如何最大限度地减少数据移动？ 一种简单的方法将使用适当的ha...","link":"","photos":[],"count_time":{"symbolsCount":"2k","symbolsTime":"2 mins."},"categories":[],"tags":[{"name":"系统设计模式","slug":"系统设计模式","count":2,"path":"api/tags/系统设计模式.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E8%83%8C%E6%99%AF\"><span class=\"toc-text\">背景</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%AE%9A%E4%B9%89\"><span class=\"toc-text\">定义</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E8%A7%A3%E5%86%B3\"><span class=\"toc-text\">解决</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E8%99%9A%E6%8B%9F%E8%8A%82%E7%82%B9\"><span class=\"toc-text\">虚拟节点</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E8%99%9A%E6%8B%9F%E8%8A%82%E7%82%B9%E7%9A%84%E4%BC%98%E5%8A%BF\"><span class=\"toc-text\">虚拟节点的优势</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E4%BE%8B%E5%AD%90\"><span class=\"toc-text\">例子</span></a></li></ol>","author":{"name":"李志博的博客","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"分享Java、中间件 等技术与学习笔记。","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}},"mapped":true,"prev_post":{},"next_post":{"title":"BloomFilters","uid":"1d4e4cde9c655456c3b6951c0ffa8502","slug":"BloomFilters","date":"2022-06-19T01:28:08.000Z","updated":"2022-06-19T03:05:08.210Z","comments":true,"path":"api/articles/BloomFilters.json","keywords":null,"cover":[],"text":"背景如果我们在一组数据文件中存储了大量结构化数据(由记录ID标识)，那么知道哪个文件可能包含我们需要的数据的最有效方法是什么？我们不想读取每个文件，因为这样会很慢，而且我们必须从磁盘读取大量数据。一种解决方案是在每个数据文件上建立索引，并将其存储在单独的索引文件中。每个索引文件将...","link":"","photos":[],"count_time":{"symbolsCount":936,"symbolsTime":"1 mins."},"categories":[],"tags":[{"name":"系统设计模式","slug":"系统设计模式","count":2,"path":"api/tags/系统设计模式.json"}],"author":{"name":"李志博的博客","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"分享Java、中间件 等技术与学习笔记。","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}},"feature":true}}