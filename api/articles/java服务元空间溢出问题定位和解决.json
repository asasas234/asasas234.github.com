{"title":"java服务元空间溢出问题定位和解决","uid":"60f3c5982dc65db74614f2d3b50cbcc1","slug":"java服务元空间溢出问题定位和解决","date":"2023-03-17T11:54:42.000Z","updated":"2023-03-17T12:00:27.617Z","comments":true,"path":"api/articles/java服务元空间溢出问题定位和解决.json","keywords":null,"cover":[],"content":"<h2 id=\"背景\"><a href=\"#背景\" class=\"headerlink\" title=\"背景\"></a>背景</h2><p>周2的时候，业务找我，1个离线任务没跑完就停了，发现原来是pod自动重启了，查找容器重启前的日志，我发现是元空间内存溢出了:</p>\n<p><img src=\"/../img/image-20230317195851177.png\" alt=\"image-20230317195851177\"></p>\n<h2 id=\"定位问题\"><a href=\"#定位问题\" class=\"headerlink\" title=\"定位问题\"></a>定位问题</h2><p>首先我加了如下启动参数，这样我就可以观测到Java内存各区域的使用情况</p>\n<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\">-XX:NativeMemoryTracking&#x3D;summary</code></pre>\n\n<p>然后通过执行如下命令：</p>\n<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\">jcmd 33 VM.native_memory summary</code></pre>\n\n<p>结果如下</p>\n<p><img src=\"/../img/image-20230317195913968.png\" alt=\"image-20230317195913968\"></p>\n<p>可以看到Class的区域比较大，当时我们最大元空间大小设置的是256MB（全公司默认配置）。这实际已经超了。</p>\n<p>后来实际是因为我之前曾经看过这个系统在跑的任务的代码，突然想起，有1个位置调了Java的脚本引擎的API，动态执行了JS的脚本，并且JS脚本是动态拼的，每次都不一样，而程序是把ScriptEngine设置到了属性上去。这就导致了每次动态创建类得不到释放，最终导致了元空间的内存溢出。</p>\n<h2 id=\"解决方案\"><a href=\"#解决方案\" class=\"headerlink\" title=\"解决方案\"></a>解决方案</h2><p>首先我们把ScriptEngine挪到了方法里去，这样方法执行完，触发它的垃圾回收，避免动态的类被引用。</p>\n<p>上完线以后，我们发现还是会重启，我们怀疑创建动态类的速度超过了回收的速度，于是我们把上游跑任务的线程池，从100调到了20，并增大了元空间大小，从256MB改成了512MB。在也没有元空间OOM的情况了。</p>\n<h2 id=\"更好的解决方案\"><a href=\"#更好的解决方案\" class=\"headerlink\" title=\"更好的解决方案\"></a>更好的解决方案</h2><p>经研究发现，其实只需要换1个js引擎，用Graal.js就可以解决这个问题，执行脚本的时候，是在JVM里解析执行的，并不存在动态创建Class的过程。</p>\n<p>代码如下</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public static void main(String[] args) &#123;\n        &#x2F;&#x2F;try (Context context &#x3D; Context.newBuilder(&quot;js&quot;).allowAllAccess(true).build()) &#123;\n        try (Context context &#x3D; Context.create(&quot;js&quot;)) &#123;\n            for (int i &#x3D; 0; i &lt; 100000000; i++) &#123;\n                String script &#x3D; &quot;(function(arg)&#123; if(arg !&#x3D;&#x3D; null &amp;&amp; arg.length &gt; 0 &amp;&amp; arg[0].status&#x3D;&#x3D;1)&#123;&quot; +\n                        &quot;    return &quot; + i + &quot;; &quot; +\n                        &quot;   &#125;&quot; +\n                        &quot;    return 0; &#125;) (PROP)  &gt; NUMBER0&quot;;\n                Value js &#x3D; context.getBindings(&quot;js&quot;);\n                js.putMember(&quot;PROP&quot;, ProxyArray.fromList(Collections.singletonList\n                        (ProxyObject.fromMap(Collections.singletonMap(&quot;status&quot;, 1)))));\n                js.putMember(&quot;NUMBER0&quot;, 0);\n                context.eval(&quot;js&quot;, script);\n            &#125;\n        &#125;\n    &#125;</code></pre>\n\n<p>效果如下:</p>\n<p><img src=\"/../img/image-20230317195933462.png\" alt=\"image-20230317195933462\"></p>\n<p><img src=\"/../img/image-20230317195946963.png\" alt=\"image-20230317195946963\"></p>\n<p>可以看到我加了打印类加载日志的参数，但是控制台并没有加载类的日志输出</p>\n<p>jprofiler 上也看不到类的增长。</p>\n","feature":true,"text":"背景周2的时候，业务找我，1个离线任务没跑完就停了，发现原来是pod自动重启了，查找容器重启前的日志，我发现是元空间内存溢出了: 定位问题首先我加了如下启动参数，这样我就可以观测到Java内存各区域的使用情况 -XX:NativeMemoryTracking&#x3D;summa...","link":"","photos":[],"count_time":{"symbolsCount":"1.8k","symbolsTime":"2 mins."},"categories":[],"tags":[{"name":"jvm","slug":"jvm","count":1,"path":"api/tags/jvm.json"},{"name":"java","slug":"java","count":1,"path":"api/tags/java.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E8%83%8C%E6%99%AF\"><span class=\"toc-text\">背景</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%AE%9A%E4%BD%8D%E9%97%AE%E9%A2%98\"><span class=\"toc-text\">定位问题</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88\"><span class=\"toc-text\">解决方案</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E6%9B%B4%E5%A5%BD%E7%9A%84%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88\"><span class=\"toc-text\">更好的解决方案</span></a></li></ol>","author":{"name":"李志博的博客","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"分享Java、中间件 等技术与学习笔记。","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}},"mapped":true,"prev_post":{},"next_post":{"title":"故障定位:syn_sent状态连接卡了好几个小时原因分析.md","uid":"0e7cfd3930040ef604ac0ea63529d122","slug":"syn-sent状态连接卡了好几个小时原因分析-md","date":"2023-03-03T05:24:48.000Z","updated":"2023-03-03T05:31:10.743Z","comments":true,"path":"api/articles/syn-sent状态连接卡了好几个小时原因分析-md.json","keywords":null,"cover":[],"text":"这周我在pre环境重启了1个Java应用，发现起了2个小时也没起来，我通过执行如下命令定位到是启动时跟MYSQL建立连接的时候失败了 联系运维，才知道，目标的数据库已经下线了，但是我比较好奇，为什么1个连接能卡这么久，它没有超时吗？ 今天早上看书的时候发现，tcp建立连接的时候，...","link":"","photos":[],"count_time":{"symbolsCount":642,"symbolsTime":"1 mins."},"categories":[],"tags":[{"name":"linux","slug":"linux","count":2,"path":"api/tags/linux.json"}],"author":{"name":"李志博的博客","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"分享Java、中间件 等技术与学习笔记。","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}},"feature":true}}