{"title":"介绍红黑树","uid":"d7ce011fd2434eab0f67698b6d1bed31","slug":"介绍红黑树","date":"2022-09-24T07:31:24.000Z","updated":"2022-09-25T01:39:20.722Z","comments":true,"path":"api/articles/介绍红黑树.json","keywords":null,"cover":[],"content":"<h2 id=\"1-介绍\"><a href=\"#1-介绍\" class=\"headerlink\" title=\"1. 介绍\"></a>1. 介绍</h2><p>在本文中，我们将了解什么是红黑树，以及为什么它们是如此流行的数据结构。</p>\n<p>我们将从查看二叉搜索树和2-3棵树开始。从这里，我们将看到红黑树如何被认为是平衡2-3树的不同代表。</p>\n<p>本文的目的是以一种简单的方式解释红黑树，因此我们不会深入研究所有可能的插入和删除情况的代码示例或详细示例。</p>\n<h2 id=\"2-二叉搜索树\"><a href=\"#2-二叉搜索树\" class=\"headerlink\" title=\"2.二叉搜索树\"></a>2.二叉搜索树</h2><p>二叉搜索树(BST)是一种树，其中每个节点都有0、1或2个子节点。没有子节点的节点称为叶。此外，节点的左子节点的值必须小于该节点的值，而右子节点的值必须大于该节点的值。</p>\n<p>让我们从一个简单的例子开始：</p>\n<img src=\"../img/image-20220924153828919.png\" alt=\"image-20220924153828919\" style=\"zoom:50%;\" />\n\n<p>我们有4，8，12，16，18，24，32号元素。我们可以以元素16作为根(A)开始我们的树，然后插入8和24(B)，最后插入元素4、12、18和32(C)。请注意，左子对象始终小于其父对象，而右子对象始终大于其父对象。我们可以很容易地看到，树的高度是logn，n是元素的数量。</p>\n<p>如果我们想要在树中搜索元素，我们可以从根开始。如果我们正在寻找的元素等于根，那么我们就完成了。如果它更小，我们继续向左搜索，如果它更大，我们继续向右搜索。我们继续下去，直到我们找到元素，或者直到我们到达一个叶节点(黄色)。很容易看出，我们搜索的时间复杂性为O(Logn)。</p>\n<img src=\"../img/image-20220924154203745.png\" alt=\"image-20220924154203745\" style=\"zoom:50%;\" />\n\n<p>但是，树的结构在很大程度上取决于元素的插入顺序。如果我们以24、32、16、18、12、8、4的顺序插入元素，则结果树不再是平衡的(D)。如果我们按排序顺序插入元素，结果是每个节点(E)只有一个子节点的树。这实际上是一张清单，而不是一棵树。这意味着我们寻找一个元素的最坏情况的复杂性是O(N)。</p>\n<h2 id=\"3-平衡2-3棵树\"><a href=\"#3-平衡2-3棵树\" class=\"headerlink\" title=\"3.平衡2-3棵树\"></a>3.平衡2-3棵树</h2><h3 id=\"3-1-2-3树的定义\"><a href=\"#3-1-2-3树的定义\" class=\"headerlink\" title=\"3.1 2-3树的定义\"></a>3.1 2-3树的定义</h3><p>现在我们来看看2-3棵树，它们可以帮助我们维护一棵平衡的树，无论我们以什么顺序将元素插入到树中。2-3树是具有两种类型节点的树。2节点具有一个值和两个子节点(同样，左侧的子节点具有较小的值，而右侧的子节点具有较大的值)，而3节点具有两个值和三个子节点。</p>\n<p>3节点的左子节点小于父节点的左值。中间的子值介于两个父值之间，右子的值大于父值的右值。</p>\n<h3 id=\"3-2-将元素插入到2-3树中\"><a href=\"#3-2-将元素插入到2-3树中\" class=\"headerlink\" title=\"3.2.将元素插入到2-3树中\"></a>3.2.将元素插入到2-3树中</h3><p>让我们看看如何将元素32、24、18、16、12、8、4插入到2-3树中，同时保持树的平衡。</p>\n<img src=\"../img/image-20220924155305642.png\" alt=\"image-20220924155305642\" style=\"zoom:50%;\" />\n\n<p>我们从32开始，这给了我们一个只有根节点(A)的树。然后我们插入24，这使我们在根(B)处有一个3节点。</p>\n<img src=\"../img/image-20220924155909176.png\" alt=\"image-20220924155909176\" style=\"zoom:50%;\" />\n\n<p>接下来，我们将插入下一个元素18，作为根的左子元素(因为18小于24)。这导致了一棵不平衡的树。我们可以通过将24移出3节点并将其作为根节点来获得平衡树。</p>\n<p>结果将是只有2节点的平衡树(B)。</p>\n<img src=\"../img/image-20220924160053159.png\" alt=\"image-20220924160053159\" style=\"zoom:50%;\" />\n\n<p>我们要插入的下一个元素是16。同样，我们以一个不平衡的树(A)结束。这一次，我们可以简单地将16个一级上移，与18(B)一起形成一个3节点。</p>\n<img src=\"../img/image-20220924160653576.png\" alt=\"image-20220924160653576\" style=\"zoom:50%;\" />\n\n<p>接下来，我们插入12作为我们刚刚创建的3节点(A)的左子节点。为了平衡树，我们首先将12个一级向上移动以形成临时的4节点(B)。</p>\n<p>现在，我们可以通过将中间元素16移到根元素来拆分4节点，这也为我们提供了一棵平衡良好的树(C)。</p>\n<img src=\"../img/image-20220924160906086.png\" alt=\"image-20220924160906086\" style=\"zoom:50%;\" />\n\n<p>插入8现在非常简单-我们首先创建一个12(A)的左子节点，然后将元素向上移动一层，形成一个包含12(B)的3节点。</p>\n<img src=\"../img/image-20220924161420270.png\" alt=\"image-20220924161420270\" style=\"zoom:50%;\" />\n\n<p>要插入的最后一个元素4会导致稍微复杂的插入。首先，我们创建一个左节点(A)，并将其上移一级，从而得到一个临时的4节点(B)。现在，我们可以将中间元素8向上移动一级，以获得根(C)处的4节点。</p>\n<p>在最后一步中，我们通过提取16作为根节点(D)来拆分4节点。</p>\n<h3 id=\"3-3-插入的复杂性\"><a href=\"#3-3-插入的复杂性\" class=\"headerlink\" title=\"3.3.插入的复杂性\"></a>3.3.插入的复杂性</h3><p>上面的例子表明，可以以维护平衡树的方式插入元素。</p>\n<p>然而，每次插入要执行的操作在代码中表示起来相当复杂。原因是我们需要三种不同类型的节点(2节点、3节点和4节点)。此外，我们需要区分几种不同的情况，以便将元素向上移动到3节点并合并到3节点，或者将3节点拆分成2节点。</p>\n<p>在下一节中，我们将看到红黑树如何帮助我们降低这种复杂性。</p>\n<h2 id=\"红黑树\"><a href=\"#红黑树\" class=\"headerlink\" title=\"红黑树\"></a>红黑树</h2><h3 id=\"4-1-与2-3棵树的对应\"><a href=\"#4-1-与2-3棵树的对应\" class=\"headerlink\" title=\"4.1 与2-3棵树的对应\"></a>4.1 与2-3棵树的对应</h3><p>红黑树本质上是2-3树的不同表示。让我们直接进入一个例子：</p>\n<img src=\"../img/image-20220924163151014.png\" alt=\"image-20220924163151014\" style=\"zoom:50%;\" />\n\n<p>(A)中的树显示了我们在上一节中看到的2-3棵树。我们用红色标记了3个节点，这将我们直接引向一棵红黑相间的树。我们将每个3节点拆分为两个2节点，并将两者之间的链接标记为红色。</p>\n<p>这也直接让我们了解到红黑树的两个主要特性：</p>\n<ul>\n<li>红色链接后面总是跟着两个黑色链接(因为我们拆分的3节点后面跟着三个黑色链接)。</li>\n<li>从根到叶节点的路径总是包含相同数量的黑色链接(这直接源于我们的2-3树是平衡的)。</li>\n</ul>\n<p>最重要的是，我们添加了以下两个条件：</p>\n<ul>\n<li>只有指向左子节点(较小的子节点)的链接才能为红色。这一条件进一步简化了实现。</li>\n<li>所有叶子都有空链接(Nil)。</li>\n</ul>\n<h3 id=\"4-2为什么会有这样的陈述？\"><a href=\"#4-2为什么会有这样的陈述？\" class=\"headerlink\" title=\"4.2为什么会有这样的陈述？\"></a>4.2为什么会有这样的陈述？</h3><p>简而言之，它简化了树的实现和操作。我们可以使用与二叉树相同的操作(例如，查找一个值的方式与在“普通”二叉树中完全相同)。</p>\n<h3 id=\"4-3-插入\"><a href=\"#4-3-插入\" class=\"headerlink\" title=\"4.3 插入\"></a>4.3 插入</h3><p>为了将新值插入到红黑树中，我们添加了一个新节点作为新的叶节点。当然，这会导致一棵不平衡的树。为了平衡树，我们首先将指向新节点的链接涂成红色。</p>\n<p>然后，我们只需要三种操作来重新平衡我们的树。让我们来看看这些操作。</p>\n<img src=\"../img/image-20220924165026186.png\" alt=\"image-20220924165026186\" style=\"zoom:50%;\" />\n\n<p>第一个操作是左旋转。这里，我们通过移动两个链接将子树(A)转换为子树(B)。</p>\n<img src=\"../img/image-20220924165139090.png\" alt=\"image-20220924165139090\" style=\"zoom:50%;\" />\n\n<p>第二个操作是右旋转，它与左旋转正好相反。</p>\n<img src=\"../img/image-20220924165225997.png\" alt=\"image-20220924165225997\" style=\"zoom:50%;\" />\n\n<p>第三个操作是翻转颜色。我们可以将两个红色链接更改为两个黑色链接，并将父链接更改为红色链接。</p>\n<p>这里重要的是，这三个操作都是局部操作，这意味着它们不会对整个树产生影响。</p>\n<p>在本文中，我们不会查看插入的完整示例。这里要强调的要点是，这三个简单的操作允许我们轻松地重新平衡树。</p>\n<h3 id=\"4-4-插入示例\"><a href=\"#4-4-插入示例\" class=\"headerlink\" title=\"4.4 插入示例\"></a>4.4 插入示例</h3><p>让我们看一个将元素插入到红黑树中的示例。我们要插入的元素是37(橙色背景)，根显示为蓝色背景。</p>\n<img src=\"../img/image-20220925085530821.png\" alt=\"image-20220925085530821\" style=\"zoom:50%;\" />\n\n<p>首先，我们从根开始，沿着树向下遍历，直到找到插入元素的叶节点。在我们的例子中，37将是树中最大的元素，所以它在最右边。指向新节点的链接是红色的，我们得到一棵树，如(A)所示。</p>\n<img src=\"../img/image-20220925085541639.png\" alt=\"image-20220925085541639\" style=\"zoom:50%;\" />\n\n<p>由于父元素36现在有两个红色链接，因此第二步是翻转颜色操作，它将我们带到树，如(B)所示。</p>\n<img src=\"../img/image-20220925091232163.png\" alt=\"image-20220925091232163\" style=\"zoom:50%;\" />\n\n<p>由于现在值为28的节点有两个红色链接，第三步再次是翻转颜色操作，这将通向树，如(C)所示。</p>\n<img src=\"../img/image-20220925091333932.png\" alt=\"image-20220925091333932\" style=\"zoom:50%;\" />\n\n<p>因为我们希望所有的红色链接都向左倾斜，所以我们进行了向左旋转，这将指向(D)中的树，其中28是根。我们可以很容易地看出这棵树是平衡的。</p>\n<h3 id=\"4-5-删除\"><a href=\"#4-5-删除\" class=\"headerlink\" title=\"4.5. 删除\"></a>4.5. 删除</h3><p>在删除节点后，我们可以使用相同的三个操作来重新平衡树。在本文中，我们不会讨论完整的实现，而只是概述其思想，并给出几个删除元素的示例。</p>\n<p>对于所有示例，我们将从以下(有效的)红黑树开始：</p>\n<img src=\"../img/image-20220925093015356.png\" alt=\"image-20220925093015356\" style=\"zoom:50%;\" />\n\n<p>最普通的情况是删除带有红色链接的叶节点。让我们来看看两种可能的情况，删除2和36。</p>\n<h4 id=\"删除2\"><a href=\"#删除2\" class=\"headerlink\" title=\"删除2\"></a>删除2</h4><img src=\"../img/image-20220925093048971.png\" alt=\"image-20220925093048971\" style=\"zoom:50%;\" />\n\n<p>这是最简单的情况。元素2是红色链接的左侧节点，因此我们可以删除它，直接得到有效的红黑树，而不需要重新平衡。</p>\n<h4 id=\"Delete-36\"><a href=\"#Delete-36\" class=\"headerlink\" title=\"Delete 36\"></a>Delete 36</h4><img src=\"../img/image-20220925093111535.png\" alt=\"image-20220925093111535\" style=\"zoom:50%;\" />\n\n<p>如果我们想删除36，我们再次删除节点，但是，由于36是红色链接的右侧节点，我们需要将链接从28更改为36以指向32。同样，我们得到了一棵有效的红黑树。</p>\n<h4 id=\"Delete-8\"><a href=\"#Delete-8\" class=\"headerlink\" title=\"Delete 8\"></a>Delete 8</h4><p>如果我们想要删除非叶节点，我们可以首先将其设置为叶节点。为此，我们找到左子树的最大元素或右子树的最小元素。此交换不会更改红黑树属性。<strong>因为我们可以将每个节点移动到树的底部，所以了解如何删除叶节点就足够了。</strong></p>\n<p>让我们来看看如何删除元素8。左子树的最大值是4(A)。因此，我们交换节点8和4并将其删除。因为8有一个红色链接，所以我们有相同的琐碎情况，就像我们删除了元素4(B)一样。</p>\n<img src=\"../img/image-20220925093344240.png\" alt=\"image-20220925093344240\" style=\"zoom:50%;\" />\n\n<p>同样，最终的树是有效的红黑树(C)。</p>\n<img src=\"../img/image-20220925093400087.png\" alt=\"image-20220925093400087\" style=\"zoom:50%;\" />\n\n<h4 id=\"Delete-24\"><a href=\"#Delete-24\" class=\"headerlink\" title=\"Delete 24\"></a>Delete 24</h4><p>如果我们想要删除不是红色链接的右或左节点的叶节点，事情就会变得稍微复杂一些。</p>\n<p>作为一个例子，让我们来看一下删除24(A)。首先，我们翻转24和18(18是左子树的最大元素)。</p>\n<p>我们现在需要删除树(B)中的24个，它没有红色链接。</p>\n<img src=\"../img/image-20220925093453763.png\" alt=\"image-20220925093453763\" style=\"zoom:50%;\" />\n\n<p>删除了24(C)的树不是有效的红黑树，因为18只有一个子树，所以树不平衡。</p>\n<img src=\"../img/image-20220925093523370.png\" alt=\"image-20220925093523370\" style=\"zoom:50%;\" />\n\n<p>我们可以用旋转(D)来平衡这棵树。</p>\n<h2 id=\"5-复杂性\"><a href=\"#5-复杂性\" class=\"headerlink\" title=\"5. 复杂性\"></a>5. 复杂性</h2><p>红黑树提供了插入、搜索和删除的对数平均和最坏情况的时间复杂度。<br>重新平衡的平均时间复杂度为O(1)，最坏情况下的复杂度为O(Logn)。</p>\n<p>此外，红黑树在进行批量和并行操作时具有有趣的特性。例如，可以通过时间复杂度为O(log(Logn))和(n&#x2F;log(Logn))个处理器的排序列表构建一棵红黑树。</p>\n<h2 id=\"6-红黑树的应用\"><a href=\"#6-红黑树的应用\" class=\"headerlink\" title=\"6. 红黑树的应用\"></a>6. 红黑树的应用</h2><p>红黑树的实际应用包括Java集合库中的TreeSet、TreeMap和Hashmap。此外，Linux内核中的完全公平调度器使用这种数据结构。Linux还在mmap和munmap操作中使用红黑树进行文件&#x2F;内存映射。</p>\n<p>此外，红黑树还用于几何范围搜索、k-均值聚类和文本挖掘。</p>\n<p>从上面的例子我们可以看到，红黑树主要是在幕后使用的，作为开发人员，我们并不经常接触它们，尽管我们每天都在使用它们。</p>\n<h2 id=\"7-结论\"><a href=\"#7-结论\" class=\"headerlink\" title=\"7. 结论\"></a>7. 结论</h2><p>在这篇文章中，我们了解了什么是红黑树，以及它们是2-3棵树的不同表现形式。</p>\n<p>我们还看到了一个表，其中总结了树上操作的复杂性，最后，我们简要总结了红黑树的一些实际应用。</p>\n<p>然而，当涉及到为特定用例选择数据结构时，有许多因素需要考虑。如果我们需要良好的插入和搜索的平均成本，以及这两种操作的对数最坏情况下的保证成本，红黑树尤其有用。</p>\n<p>此外，如果我们频繁更新树，红黑树是一个很好的选择，因为再平衡成本低于其他平衡树，例如AVL或B树。</p>\n","text":"1. 介绍在本文中，我们将了解什么是红黑树，以及为什么它们是如此流行的数据结构。 我们将从查看二叉搜索树和2-3棵树开始。从这里，我们将看到红黑树如何被认为是平衡2-3树的不同代表。 本文的目的是以一种简单的方式解释红黑树，因此我们不会深入研究所有可能的插入和删除情况的代码示例或...","link":"","photos":[],"count_time":{"symbolsCount":"3.9k","symbolsTime":"4 mins."},"categories":[],"tags":[{"name":"算法","slug":"算法","count":1,"path":"api/tags/算法.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#1-%E4%BB%8B%E7%BB%8D\"><span class=\"toc-text\">1. 介绍</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#2-%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91\"><span class=\"toc-text\">2.二叉搜索树</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#3-%E5%B9%B3%E8%A1%A12-3%E6%A3%B5%E6%A0%91\"><span class=\"toc-text\">3.平衡2-3棵树</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#3-1-2-3%E6%A0%91%E7%9A%84%E5%AE%9A%E4%B9%89\"><span class=\"toc-text\">3.1 2-3树的定义</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#3-2-%E5%B0%86%E5%85%83%E7%B4%A0%E6%8F%92%E5%85%A5%E5%88%B02-3%E6%A0%91%E4%B8%AD\"><span class=\"toc-text\">3.2.将元素插入到2-3树中</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#3-3-%E6%8F%92%E5%85%A5%E7%9A%84%E5%A4%8D%E6%9D%82%E6%80%A7\"><span class=\"toc-text\">3.3.插入的复杂性</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E7%BA%A2%E9%BB%91%E6%A0%91\"><span class=\"toc-text\">红黑树</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#4-1-%E4%B8%8E2-3%E6%A3%B5%E6%A0%91%E7%9A%84%E5%AF%B9%E5%BA%94\"><span class=\"toc-text\">4.1 与2-3棵树的对应</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#4-2%E4%B8%BA%E4%BB%80%E4%B9%88%E4%BC%9A%E6%9C%89%E8%BF%99%E6%A0%B7%E7%9A%84%E9%99%88%E8%BF%B0%EF%BC%9F\"><span class=\"toc-text\">4.2为什么会有这样的陈述？</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#4-3-%E6%8F%92%E5%85%A5\"><span class=\"toc-text\">4.3 插入</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#4-4-%E6%8F%92%E5%85%A5%E7%A4%BA%E4%BE%8B\"><span class=\"toc-text\">4.4 插入示例</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#4-5-%E5%88%A0%E9%99%A4\"><span class=\"toc-text\">4.5. 删除</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E5%88%A0%E9%99%A42\"><span class=\"toc-text\">删除2</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#Delete-36\"><span class=\"toc-text\">Delete 36</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#Delete-8\"><span class=\"toc-text\">Delete 8</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#Delete-24\"><span class=\"toc-text\">Delete 24</span></a></li></ol></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#5-%E5%A4%8D%E6%9D%82%E6%80%A7\"><span class=\"toc-text\">5. 复杂性</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#6-%E7%BA%A2%E9%BB%91%E6%A0%91%E7%9A%84%E5%BA%94%E7%94%A8\"><span class=\"toc-text\">6. 红黑树的应用</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#7-%E7%BB%93%E8%AE%BA\"><span class=\"toc-text\">7. 结论</span></a></li></ol>","author":{"name":"李志博的博客","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"分享Java、中间件 等技术与学习笔记。","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}},"mapped":true,"prev_post":{"title":"GoLang介绍与安装","uid":"90f1e8e7e7d3685880af5dfa3ff2eff7","slug":"GoLang介绍与安装","date":"2023-01-03T12:04:08.000Z","updated":"2023-01-03T13:00:43.285Z","comments":true,"path":"api/articles/GoLang介绍与安装.json","keywords":null,"cover":null,"text":"这是我们的 Golang 教程系列中的第一篇教程。本教程介绍了 Go，还讨论了选择 Go 相对于其他编程语言的优势。我们还将学习如何在 Mac OS、Windows 和 Linux 中安装 Go。 介绍Go 也称为 Golang，是一种由 Google 开发的开源、编译型和静态类...","link":"","photos":[],"count_time":{"symbolsCount":"1.8k","symbolsTime":"2 mins."},"categories":[],"tags":[{"name":"golang基础教程翻译","slug":"golang基础教程翻译","count":2,"path":"api/tags/golang基础教程翻译.json"}],"author":{"name":"李志博的博客","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"分享Java、中间件 等技术与学习笔记。","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}},"next_post":{"title":"async-profiler指南","uid":"db45217419a12dfdde75d94a88900ee9","slug":"async-profiler指南","date":"2022-09-18T02:13:39.000Z","updated":"2022-09-18T03:32:47.520Z","comments":true,"path":"api/articles/async-profiler指南.json","keywords":null,"cover":[],"text":"1. 概述Java Sampling Profilers 通常使用JVM工具接口(JVMTI)进行设计，并在安全点收集堆栈跟踪。因此，这些采样剖析器可能会受到安全点偏差问题的影响。 对于应用程序的整体视图，我们需要一个采样分析器，它不需要线程位于安全点，并且可以随时收集堆栈跟踪，...","link":"","photos":[],"count_time":{"symbolsCount":"4.4k","symbolsTime":"4 mins."},"categories":[],"tags":[{"name":"JVM","slug":"JVM","count":2,"path":"api/tags/JVM.json"}],"author":{"name":"李志博的博客","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"分享Java、中间件 等技术与学习笔记。","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}}}