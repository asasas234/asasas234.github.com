{"title":"RocketMQ-NameServer的源码阅读脉络","uid":"7a8ccfb903ca33a7195e4b4486061453","slug":"RocketMQ-NameServer的源码阅读脉络","date":"2022-05-15T04:00:02.000Z","updated":"2022-05-15T06:57:44.929Z","comments":true,"path":"api/articles/RocketMQ-NameServer的源码阅读脉络.json","keywords":null,"cover":null,"content":"<h2 id=\"启动大概流程\"><a href=\"#启动大概流程\" class=\"headerlink\" title=\"启动大概流程\"></a>启动大概流程</h2><ol>\n<li><code>NamesrvStartup</code> 是启动类，会先调<code>createNamesrvController</code> 初始化配置，然后创建<code>NamesrvController</code>, 然后调Controller的静态start方法</li>\n<li><code>NamesrvController</code>的静态Start方法会先调<code>initialize</code>方法，然后注册程序destory的钩子，最后start方法启动<ol>\n<li>在<code>initialize</code> 方法里会执行<code>registerProcessor</code>方法，会在这里注册一个<code>NettyRequestProcessor</code> 这个是1个接口，表示的是RocketMQ请求处理，在NameServer里，有2个实现，<code>ClusterTestRequestProcessor</code> 和 <code>DefaultRequestProcessor</code>其中我们主要关键的是<code>DefaultRequestProcessor</code> 。</li>\n</ol>\n</li>\n</ol>\n<h2 id=\"处理请求路由\"><a href=\"#处理请求路由\" class=\"headerlink\" title=\"处理请求路由\"></a>处理请求路由</h2><p><code>DefaultRequestProcessor</code>是NameServer里我觉得最核心的类，因为它是NameServer里负责接收并处理请求的类，通过它的<code>processRequest</code>方法，可以很直接的看到NameServer都具体负责处理哪些请求，以及这些请求具体的实现，也都可以找的到。</p>\n<h2 id=\"核心类介绍\"><a href=\"#核心类介绍\" class=\"headerlink\" title=\"核心类介绍\"></a>核心类介绍</h2><ol>\n<li><code>KVConfigManager</code> 负责管理不同Namespace下KV的配置，并存储。</li>\n<li><code>RouteInfoManager</code> 负责管理路由相关信息</li>\n<li><code>NamesrvController</code> 是1个集中的初始化整个系统的类，并且持有其他核心类的依赖，其他类核心类都持有<code>NamesrvController</code>的引用，要跟另外个类调用，都是通过<code>NamesrvController</code>来获取这个类的引用，相当于1个解耦的作用。</li>\n</ol>\n","text":"启动大概流程 NamesrvStartup 是启动类，会先调createNamesrvController 初始化配置，然后创建NamesrvController, 然后调Controller的静态start方法 NamesrvController的静态Start方法会先调ini...","link":"","photos":[],"count_time":{"symbolsCount":739,"symbolsTime":"1 mins."},"categories":[],"tags":[{"name":"RocketMQ","slug":"RocketMQ","count":1,"path":"api/tags/RocketMQ.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%90%AF%E5%8A%A8%E5%A4%A7%E6%A6%82%E6%B5%81%E7%A8%8B\"><span class=\"toc-text\">启动大概流程</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%A4%84%E7%90%86%E8%AF%B7%E6%B1%82%E8%B7%AF%E7%94%B1\"><span class=\"toc-text\">处理请求路由</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E6%A0%B8%E5%BF%83%E7%B1%BB%E4%BB%8B%E7%BB%8D\"><span class=\"toc-text\">核心类介绍</span></a></li></ol>","author":{"name":"李志博的博客","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"分享Java、中间件 等技术与学习笔记。","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}},"mapped":true,"prev_post":{"title":"高级文件IO","uid":"56a9693faf1b310ae2faaa7452bad4b8","slug":"高级文件IO","date":"2022-05-15T14:50:22.000Z","updated":"2022-05-17T15:24:40.530Z","comments":true,"path":"api/articles/高级文件IO.json","keywords":null,"cover":[],"text":"通常，人们会对CPU及其性能感到紧张。虽然很重要，但在许多实际应用程序工作负载中，拖累性能的不是CPU，而是I&#x2F;O代码路径。这是完全可以理解的；回想一下，在第2章-虚拟内存中，我们展示了与RAM相比，磁盘速度慢了几个数量级。这种情况与网络I&#x2F;O类似；因此，由于...","link":"","photos":[],"count_time":{"symbolsCount":"15k","symbolsTime":"13 mins."},"categories":[],"tags":[{"name":"linux","slug":"linux","count":2,"path":"api/tags/linux.json"},{"name":"IO","slug":"IO","count":1,"path":"api/tags/IO.json"}],"author":{"name":"李志博的博客","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"分享Java、中间件 等技术与学习笔记。","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}},"next_post":{"title":"Maven多模块统一管理版本","uid":"957c5556bfb48cc069f3d5abcb598019","slug":"Maven多模块统一管理版本","date":"2022-05-14T05:27:00.000Z","updated":"2022-05-14T06:00:29.061Z","comments":true,"path":"api/articles/Maven多模块统一管理版本.json","keywords":null,"cover":null,"text":"之前写多模块项目的时候，一般都需要保证各模块的版本号是一致的，所以导致每次代码有变动需要升级版本的时候，都需要全局挨个替换，但是这种方式太麻烦，也不够优雅，由于最近工作是维护公司的apollo，所以我看了下apollo的pom文件里的方式，觉得还不错。 首先是要在多模块项目里的父...","link":"","photos":[],"count_time":{"symbolsCount":"1k","symbolsTime":"1 mins."},"categories":[],"tags":[{"name":"maven","slug":"maven","count":1,"path":"api/tags/maven.json"}],"author":{"name":"李志博的博客","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"分享Java、中间件 等技术与学习笔记。","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}}}