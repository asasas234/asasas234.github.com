{"title":"翻译bpf-performance-tools第7章内存","uid":"ece203b53ac6e642a41832310009d6ab","slug":"翻译bpf-performance-tools第7章内存","date":"2022-05-21T12:29:12.000Z","updated":"2022-05-22T07:58:20.369Z","comments":true,"path":"api/articles/翻译bpf-performance-tools第7章内存.json","keywords":null,"cover":[],"content":"<p>Linux是一个基于虚拟内存的系统，其中每个进程都有自己的虚拟地址空间，并按需映射到物理内存。它的设计允许超额订阅物理内存，Linux通过一个页出守护进程和物理交换设备以及(作为最后手段)内存不足(OOM)杀手来管理物理内存。Linux使用空闲内存作为文件系统缓存，这一主题将在第8章中介绍。</p>\n<p>本章展示了BPF如何以新的方式公开应用程序内存使用情况，并帮助您检查内核如何应对内存压力。随着CPU可伸缩性的增长快于内存速度，内存I&#x2F;O已成为新的瓶颈。了解内存使用情况可以获得许多性能优势。</p>\n<p>学习目标：</p>\n<ul>\n<li>了解内存分配和分页行为</li>\n<li>了解使用跟踪器成功分析内存行为的策略</li>\n<li>使用传统工具了解内存容量使用情况</li>\n<li>使用BPF工具识别导致堆和RSS增长的代码路径</li>\n<li>通过文件名和堆栈跟踪来表征页面错误</li>\n<li>分析VM扫描程序的行为</li>\n<li>确定内存回收对性能的影响</li>\n<li>确定哪些进程正在等待换入</li>\n<li>使用bpftrace一行程序以自定义方式探索内存使用情况</li>\n</ul>\n<p>本章从内存分析的一些必要背景开始，重点介绍应用程序的使用情况、总结虚拟和物理分配以及分页。探讨了BPF可以回答的问题，以及应遵循的总体战略。首先总结传统的内存分析工具，然后介绍BPF工具，包括BPF一行程序列表。本章以可选练习结束。</p>\n<h2 id=\"7-1背景\"><a href=\"#7-1背景\" class=\"headerlink\" title=\"7.1背景\"></a>7.1背景</h2><p>本节介绍内存基础知识、BPF功能以及建议的内存分析策略。</p>\n<h3 id=\"7-1-1内存基础知识\"><a href=\"#7-1-1内存基础知识\" class=\"headerlink\" title=\"7.1.1内存基础知识\"></a>7.1.1内存基础知识</h3><h4 id=\"内存分配器\"><a href=\"#内存分配器\" class=\"headerlink\" title=\"内存分配器\"></a><strong>内存分配器</strong></h4><p>图7-1显示了用户级和内核级软件常用的内存分配系统。对于使用libc进行内存分配的进程，内存存储在进程的虚拟地址空间的动态段中，称为堆。Libc提供内存分配函数，包括Malloc()和Free()。当内存被释放时，libc跟踪它的位置，并可以使用该位置信息来完成后续的Malloc()。只有在没有可用内存时，libc才需要扩展堆的大小。Libc通常没有理由缩小堆的大小，因为这都是虚拟内存，而不是真正的物理内存。</p>\n<p><img src=\"https://learning.oreilly.com/api/v2/epubs/urn:orm:book:9780136588870/files/graphics/07fig01.jpg\" alt=\"img\"></p>\n<p><strong>图 7-1</strong> 内存分配</p>\n","feature":true,"text":"Linux是一个基于虚拟内存的系统，其中每个进程都有自己的虚拟地址空间，并按需映射到物理内存。它的设计允许超额订阅物理内存，Linux通过一个页出守护进程和物理交换设备以及(作为最后手段)内存不足(OOM)杀手来管理物理内存。Linux使用空闲内存作为文件系统缓存，这一主题将在第...","link":"","photos":[],"count_time":{"symbolsCount":800,"symbolsTime":"1 mins."},"categories":[],"tags":[{"name":"linux","slug":"linux","count":2,"path":"api/tags/linux.json"},{"name":"Memory","slug":"Memory","count":1,"path":"api/tags/Memory.json"},{"name":"bpf","slug":"bpf","count":1,"path":"api/tags/bpf.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#7-1%E8%83%8C%E6%99%AF\"><span class=\"toc-text\">7.1背景</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#7-1-1%E5%86%85%E5%AD%98%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86\"><span class=\"toc-text\">7.1.1内存基础知识</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E5%99%A8\"><span class=\"toc-text\">内存分配器</span></a></li></ol></li></ol></li></ol>","author":{"name":"李志博的博客","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"分享Java、中间件 等技术与学习笔记。","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}},"mapped":true,"prev_post":{"title":"Eclipse-Collection之IntIntHashMap","uid":"e939d2a67c854d9584266b38aea34ab3","slug":"Eclipse-Collection之IntIntHashMap","date":"2022-05-23T14:09:07.000Z","updated":"2022-05-23T14:21:20.966Z","comments":true,"path":"api/articles/Eclipse-Collection之IntIntHashMap.json","keywords":null,"cover":[],"text":"最近在设计1个功能，其中需要内存保存数据的全量索引，结构大概如下: Map&lt;Integer,Integer&gt; indexMap &#x3D; new HashMap&lt;&gt;(); 我跑单测观察这个Map占用内存的时候发现，110多万的数据要消耗500多MB内存...","link":"","photos":[],"count_time":{"symbolsCount":"1.3k","symbolsTime":"1 mins."},"categories":[],"tags":[{"name":"Java","slug":"Java","count":2,"path":"api/tags/Java.json"},{"name":"Eclipse-Collection","slug":"Eclipse-Collection","count":1,"path":"api/tags/Eclipse-Collection.json"}],"author":{"name":"李志博的博客","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"分享Java、中间件 等技术与学习笔记。","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}},"feature":true},"next_post":{"title":"native内存最佳实践","uid":"f929186e789271318e9dfdac1fb85b07","slug":"native内存最佳实践","date":"2022-05-21T01:43:03.000Z","updated":"2022-05-21T08:57:15.547Z","comments":true,"path":"api/articles/native内存最佳实践.json","keywords":null,"cover":[],"text":"堆是Java应用程序中最大的内存消耗者，但JVM将分配和使用大量本机内存。虽然第7章从编程的角度讨论了有效管理堆的方法，但堆的配置以及它如何与操作系统的本机内存交互是影响应用程序整体性能的另一个重要因素。这里存在术语冲突，因为C程序员倾向于将其本机内存的一部分称为C堆。为了与以J...","link":"","photos":[],"count_time":{"symbolsCount":"15k","symbolsTime":"14 mins."},"categories":[],"tags":[{"name":"Java","slug":"Java","count":2,"path":"api/tags/Java.json"},{"name":"JVM","slug":"JVM","count":1,"path":"api/tags/JVM.json"}],"author":{"name":"李志博的博客","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"分享Java、中间件 等技术与学习笔记。","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}},"feature":true}}