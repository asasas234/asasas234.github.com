{"title":"Mockito跟SpringBoot@Autowired组合使用方式","uid":"9f14b7d15ba15e4a4bdd3158410a83f4","slug":"Mockito跟SpringBoot-Autowired组合使用方式","date":"2022-06-04T06:10:53.000Z","updated":"2022-06-05T01:52:56.700Z","comments":true,"path":"api/articles/Mockito跟SpringBoot-Autowired组合使用方式.json","keywords":null,"cover":null,"content":"<p>有的时候，我们想绝大多数Bean在单测的时候，还是希望走正常的Bean注入,只有少部分Bean需要自己人工Mock结果，这个时候如何优雅的Mock Bean实例并自动和其他Bean实例一样进行注入呢？</p>\n<p>可以通过Mockito的@MockBean注解解决，代码如下</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">@SpringBootTest\nclass CubeDataCacheServiceTest &#123;\n\n    @Autowired\n    private CubeDataCacheService cubeDataCacheService;\n\n    @MockBean\n    private DimensionLocalService dimensionLocalService;\n&#125;</code></pre>\n\n<p>以上代码把一些不相关的代码都去掉了，接着我们就可以正常的调mockito的API，进行正常的设置mock结果就好了。</p>\n","text":"有的时候，我们想绝大多数Bean在单测的时候，还是希望走正常的Bean注入,只有少部分Bean需要自己人工Mock结果，这个时候如何优雅的Mock Bean实例并自动和其他Bean实例一样进行注入呢？ 可以通过Mockito的@MockBean注解解决，代码如下 @SpringB...","link":"","photos":[],"count_time":{"symbolsCount":396,"symbolsTime":"1 mins."},"categories":[],"tags":[{"name":"mockito","slug":"mockito","count":1,"path":"api/tags/mockito.json"},{"name":"SpringBoot","slug":"SpringBoot","count":2,"path":"api/tags/SpringBoot.json"}],"toc":"","author":{"name":"李志博的博客","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"分享Java、中间件 等技术与学习笔记。","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}},"mapped":true,"prev_post":{"title":"记录一次从入行到现在搞过的1个最有技术含量的设计与实现","uid":"333947e26625255057a67cb03ae27773","slug":"记录一次从入行到现在搞过的1个最有技术含量的设计与实现","date":"2022-06-05T06:55:29.000Z","updated":"2022-06-05T12:12:55.130Z","comments":true,"path":"api/articles/记录一次从入行到现在搞过的1个最有技术含量的设计与实现.json","keywords":null,"cover":[],"text":"背景最近工作中需要做1个很有意思并且有一定挑战的事情，项目里有1个接口，如果是第一次查询，会一次性查整个表的所有数据，然后缓存在JVM内部，后续的搜索就都会查这个缓存，这个方案肯定是不合理的，但是未来也是有计划迁移到另外1个替代它的项目上，但是在迁移之前，领导叫我临时性的做下内存...","link":"","photos":[],"count_time":{"symbolsCount":"5.7k","symbolsTime":"5 mins."},"categories":[],"tags":[{"name":"Java","slug":"Java","count":4,"path":"api/tags/Java.json"},{"name":"工作","slug":"工作","count":1,"path":"api/tags/工作.json"}],"author":{"name":"李志博的博客","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"分享Java、中间件 等技术与学习笔记。","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}},"feature":true},"next_post":{"title":"Eclipse-Collection之IntIntHashMap","uid":"e939d2a67c854d9584266b38aea34ab3","slug":"Eclipse-Collection之IntIntHashMap","date":"2022-05-23T14:09:07.000Z","updated":"2022-05-23T14:21:20.966Z","comments":true,"path":"api/articles/Eclipse-Collection之IntIntHashMap.json","keywords":null,"cover":[],"text":"最近在设计1个功能，其中需要内存保存数据的全量索引，结构大概如下: Map&lt;Integer,Integer&gt; indexMap &#x3D; new HashMap&lt;&gt;(); 我跑单测观察这个Map占用内存的时候发现，110多万的数据要消耗500多MB内存...","link":"","photos":[],"count_time":{"symbolsCount":"1.3k","symbolsTime":"1 mins."},"categories":[],"tags":[{"name":"Java","slug":"Java","count":4,"path":"api/tags/Java.json"},{"name":"Eclipse-Collection","slug":"Eclipse-Collection","count":1,"path":"api/tags/Eclipse-Collection.json"}],"author":{"name":"李志博的博客","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"分享Java、中间件 等技术与学习笔记。","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}}}