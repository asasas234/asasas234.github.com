{"name":"JVM","slug":"JVM","count":2,"postlist":[{"title":"native内存最佳实践","uid":"f929186e789271318e9dfdac1fb85b07","slug":"native内存最佳实践","date":"2022-05-21T01:43:03.000Z","updated":"2022-05-21T08:57:15.547Z","comments":true,"path":"api/articles/native内存最佳实践.json","keywords":null,"cover":[],"text":"堆是Java应用程序中最大的内存消耗者，但JVM将分配和使用大量本机内存。虽然第7章从编程的角度讨论了有效管理堆的方法，但堆的配置以及它如何与操作系统的本机内存交互是影响应用程序整体性能的另一个重要因素。这里存在术语冲突，因为C程序员倾向于将其本机内存的一部分称为C堆。为了与以J...","link":"","photos":[],"count_time":{"symbolsCount":"15k","symbolsTime":"14 mins."},"categories":[],"tags":[{"name":"Java","slug":"Java","count":5,"path":"api/tags/Java.json"},{"name":"JVM","slug":"JVM","count":2,"path":"api/tags/JVM.json"}],"author":{"name":"李志博的博客","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"分享Java、中间件 等技术与学习笔记。","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}},{"title":"async-profiler指南","uid":"db45217419a12dfdde75d94a88900ee9","slug":"async-profiler指南","date":"2022-09-18T02:13:39.000Z","updated":"2022-09-18T03:32:47.520Z","comments":true,"path":"api/articles/async-profiler指南.json","keywords":null,"cover":[],"text":"1. 概述Java Sampling Profilers 通常使用JVM工具接口(JVMTI)进行设计，并在安全点收集堆栈跟踪。因此，这些采样剖析器可能会受到安全点偏差问题的影响。 对于应用程序的整体视图，我们需要一个采样分析器，它不需要线程位于安全点，并且可以随时收集堆栈跟踪，...","link":"","photos":[],"count_time":{"symbolsCount":"4.4k","symbolsTime":"4 mins."},"categories":[],"tags":[{"name":"JVM","slug":"JVM","count":2,"path":"api/tags/JVM.json"}],"author":{"name":"李志博的博客","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"分享Java、中间件 等技术与学习笔记。","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}}]}