{"name":"李志博的博客","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"分享Java、中间件 等技术与学习笔记。","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}},"post_list":[{"title":"GoLang介绍与安装","uid":"90f1e8e7e7d3685880af5dfa3ff2eff7","slug":"GoLang介绍与安装","date":"2023-01-03T12:04:08.000Z","updated":"2023-01-03T13:00:43.285Z","comments":true,"path":"api/articles/GoLang介绍与安装.json","keywords":null,"cover":null,"text":"这是我们的 Golang 教程系列中的第一篇教程。本教程介绍了 Go，还讨论了选择 Go 相对于其他编程语言的优势。我们还将学习如何在 Mac OS、Windows 和 Linux 中安装 Go。 介绍Go 也称为 Golang，是一种由 Google 开发的开源、编译型和静态类...","link":"","photos":[],"count_time":{"symbolsCount":"1.8k","symbolsTime":"2 mins."},"categories":[],"tags":[{"name":"golang基础教程翻译","slug":"golang基础教程翻译","count":1,"path":"api/tags/golang基础教程翻译.json"}],"author":{"name":"李志博的博客","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"分享Java、中间件 等技术与学习笔记。","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}},"feature":true},{"title":"介绍红黑树","uid":"d7ce011fd2434eab0f67698b6d1bed31","slug":"介绍红黑树","date":"2022-09-24T07:31:24.000Z","updated":"2022-09-25T01:39:20.722Z","comments":true,"path":"api/articles/介绍红黑树.json","keywords":null,"cover":[],"text":"1. 介绍在本文中，我们将了解什么是红黑树，以及为什么它们是如此流行的数据结构。 我们将从查看二叉搜索树和2-3棵树开始。从这里，我们将看到红黑树如何被认为是平衡2-3树的不同代表。 本文的目的是以一种简单的方式解释红黑树，因此我们不会深入研究所有可能的插入和删除情况的代码示例或...","link":"","photos":[],"count_time":{"symbolsCount":"3.9k","symbolsTime":"4 mins."},"categories":[],"tags":[{"name":"算法","slug":"算法","count":1,"path":"api/tags/算法.json"}],"author":{"name":"李志博的博客","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"分享Java、中间件 等技术与学习笔记。","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}},"feature":true},{"title":"async-profiler指南","uid":"db45217419a12dfdde75d94a88900ee9","slug":"async-profiler指南","date":"2022-09-18T02:13:39.000Z","updated":"2022-09-18T03:32:47.520Z","comments":true,"path":"api/articles/async-profiler指南.json","keywords":null,"cover":[],"text":"1. 概述Java Sampling Profilers 通常使用JVM工具接口(JVMTI)进行设计，并在安全点收集堆栈跟踪。因此，这些采样剖析器可能会受到安全点偏差问题的影响。 对于应用程序的整体视图，我们需要一个采样分析器，它不需要线程位于安全点，并且可以随时收集堆栈跟踪，...","link":"","photos":[],"count_time":{"symbolsCount":"4.4k","symbolsTime":"4 mins."},"categories":[],"tags":[{"name":"JVM","slug":"JVM","count":2,"path":"api/tags/JVM.json"}],"author":{"name":"李志博的博客","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"分享Java、中间件 等技术与学习笔记。","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}},"feature":true},{"title":"MySQL快速导入数据","uid":"a6af7b290f5171db5db2fabe49e62533","slug":"MySQL快速导入数据","date":"2022-07-22T07:30:59.000Z","updated":"2022-07-22T07:56:17.659Z","comments":true,"path":"api/articles/MySQL快速导入数据.json","keywords":null,"cover":null,"text":"由于公司内网到测试环境网速太慢，所以当导大批量数据的时候，如果直接通过本地GUI工具去导入，速度会很慢，这个时候可以直接登录到测试环境MYSQL的服务器上，通过命令进行导入就会很快，因为省去了数据文件传输的步骤（运维提前帮忙传好） LOAD DATA LOCAL INFILE &...","link":"","photos":[],"count_time":{"symbolsCount":465,"symbolsTime":"1 mins."},"categories":[],"tags":[{"name":"mysql","slug":"mysql","count":2,"path":"api/tags/mysql.json"}],"author":{"name":"李志博的博客","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"分享Java、中间件 等技术与学习笔记。","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}},{"title":"从MySQL导出数据到Clickhouse","uid":"4f77ff7005cc894f0fb8ca8b1f9e018f","slug":"从MySQL导出数据到Clickhouse","date":"2022-07-03T07:46:27.000Z","updated":"2022-07-03T08:27:03.963Z","comments":true,"path":"api/articles/从MySQL导出数据到Clickhouse.json","keywords":null,"cover":null,"text":"最开始我用的笨办法，先把MYSQL数据导出成CSV格式，在用图形化的方式导入，发现速度特别慢，原因是因为公司本机的网络到公司的测试环境服务器的网络延迟特别高，而这种办法需要来回传送大量的数据。 后来我网上查到一种方法，只需要执行1条SQL，就可以直接把MYSQL的数据写入到CK里...","link":"","photos":[],"count_time":{"symbolsCount":316,"symbolsTime":"1 mins."},"categories":[],"tags":[{"name":"clickhouse","slug":"clickhouse","count":1,"path":"api/tags/clickhouse.json"}],"author":{"name":"李志博的博客","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"分享Java、中间件 等技术与学习笔记。","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}},{"title":"脑裂","uid":"5c47efdc17eed2217ef995cf017168a8","slug":"脑裂","date":"2022-07-03T06:27:45.000Z","updated":"2022-10-02T08:36:26.156Z","comments":true,"path":"api/articles/脑裂.json","keywords":null,"cover":null,"text":"背景在具有中央(或领导)服务器的分布式环境中，如果中央服务器死机，系统必须迅速找到替代服务器，否则，系统可能会迅速恶化。 其中一个问题是，我们不能真正知道领导者是否已经永久停止，或者是否经历了间歇性故障，如停止世界GC暂停或临时网络中断。然而，集群必须继续前进，并挑选一个新的领导...","link":"","photos":[],"count_time":{"symbolsCount":576,"symbolsTime":"1 mins."},"categories":[],"tags":[{"name":"系统设计模式","slug":"系统设计模式","count":5,"path":"api/tags/系统设计模式.json"},{"name":"分布式","slug":"分布式","count":2,"path":"api/tags/分布式.json"}],"author":{"name":"李志博的博客","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"分享Java、中间件 等技术与学习笔记。","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}},{"title":"故障检测","uid":"9254c5dd5c94857ab7eacd672f6ed06b","slug":"故障检测","date":"2022-07-03T06:24:41.000Z","updated":"2022-09-18T02:18:26.264Z","comments":true,"path":"api/articles/故障检测.json","keywords":null,"cover":null,"text":"背景在分布式系统中，准确地检测故障是一个很难解决的问题，因为我们不能100%肯定地说系统是否真的停机了，或者只是由于高负载、网络拥塞等原因导致响应非常慢。传统的故障检测机制，如心跳，会输出布尔值，告诉我们系统是否还活着；没有中间立场。心跳使用固定的超时，如果没有来自服务器的心跳，...","link":"","photos":[],"count_time":{"symbolsCount":523,"symbolsTime":"1 mins."},"categories":[],"tags":[{"name":"系统设计模式","slug":"系统设计模式","count":5,"path":"api/tags/系统设计模式.json"}],"author":{"name":"李志博的博客","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"分享Java、中间件 等技术与学习笔记。","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}},{"title":"Gossip Protocol","uid":"604173b86be0a2f105a1d74293a8d4b7","slug":"Gossip-Protocol","date":"2022-07-03T05:29:44.000Z","updated":"2022-10-02T08:36:00.606Z","comments":true,"path":"api/articles/Gossip-Protocol.json","keywords":null,"cover":[],"text":"背景在大型分布式环境中，我们没有任何中央节点来跟踪所有节点以知道某个节点是否停机，一个节点如何知道其他所有节点的当前状态？要做到这一点，最简单的方法是让每个节点与其他节点保持心跳。然后，当一个节点出现故障时，它将停止发送心跳信号，其他所有人都会立即发现。但是，这意味着 $O(N^...","link":"","photos":[],"count_time":{"symbolsCount":526,"symbolsTime":"1 mins."},"categories":[],"tags":[{"name":"系统设计模式","slug":"系统设计模式","count":5,"path":"api/tags/系统设计模式.json"},{"name":"分布式","slug":"分布式","count":2,"path":"api/tags/分布式.json"}],"author":{"name":"李志博的博客","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"分享Java、中间件 等技术与学习笔记。","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}},{"title":"ConditionalOnClass的坑","uid":"603da98ebad6deb878c273c2b1c31c67","slug":"ConditionalOnClass的坑","date":"2022-06-26T11:54:19.000Z","updated":"2022-06-26T12:00:52.046Z","comments":true,"path":"api/articles/ConditionalOnClass的坑.json","keywords":null,"cover":[],"text":" 上面的代码其实存在1个问题，就是ConditionalOnClass注解的使用其实是不正确的，声明在方法上并不能实现当HealthIndicator类不在classpath下的时候，这个Bean不生效，要想实现这个效果，必须要把它声明在类上，例如: @Configuration...","link":"","photos":[],"count_time":{"symbolsCount":673,"symbolsTime":"1 mins."},"categories":[],"tags":[{"name":"Spring","slug":"Spring","count":2,"path":"api/tags/Spring.json"}],"author":{"name":"李志博的博客","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"分享Java、中间件 等技术与学习笔记。","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}},{"title":"一致性Hash","uid":"02d29d69da92d1495f7e9b3c258ba0cc","slug":"一致性Hash","date":"2022-06-19T03:15:56.000Z","updated":"2022-06-19T13:44:46.114Z","comments":true,"path":"api/articles/一致性Hash.json","keywords":null,"cover":[],"text":"背景跨一组节点分发数据的行为称为数据分区。当我们尝试分发数据时，有两个挑战： 我们如何知道特定数据将存储在哪个节点上？ 当我们添加或删除节点时，我们如何知道哪些数据将从现有节点移动到新节点？此外，当节点加入或离开时，我们如何最大限度地减少数据移动？ 一种简单的方法将使用适当的ha...","link":"","photos":[],"count_time":{"symbolsCount":"2k","symbolsTime":"2 mins."},"categories":[],"tags":[{"name":"系统设计模式","slug":"系统设计模式","count":5,"path":"api/tags/系统设计模式.json"}],"author":{"name":"李志博的博客","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"分享Java、中间件 等技术与学习笔记。","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}},{"title":"BloomFilters","uid":"1d4e4cde9c655456c3b6951c0ffa8502","slug":"BloomFilters","date":"2022-06-19T01:28:08.000Z","updated":"2022-06-19T03:05:08.210Z","comments":true,"path":"api/articles/BloomFilters.json","keywords":null,"cover":[],"text":"背景如果我们在一组数据文件中存储了大量结构化数据(由记录ID标识)，那么知道哪个文件可能包含我们需要的数据的最有效方法是什么？我们不想读取每个文件，因为这样会很慢，而且我们必须从磁盘读取大量数据。一种解决方案是在每个数据文件上建立索引，并将其存储在单独的索引文件中。每个索引文件将...","link":"","photos":[],"count_time":{"symbolsCount":936,"symbolsTime":"1 mins."},"categories":[],"tags":[{"name":"系统设计模式","slug":"系统设计模式","count":5,"path":"api/tags/系统设计模式.json"}],"author":{"name":"李志博的博客","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"分享Java、中间件 等技术与学习笔记。","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}},{"title":"重新设计数据索引结构,缓存内存从2.3G降到了59MB","uid":"82b321e71a818dfcf2a53be9140d17a7","slug":"重新设计数据索引结构-缓存内存从2-3G降到了59MB","date":"2022-06-18T03:22:34.000Z","updated":"2022-06-18T07:52:13.740Z","comments":true,"path":"api/articles/重新设计数据索引结构-缓存内存从2-3G降到了59MB.json","keywords":null,"cover":[],"text":"背景之前写过的文件缓存的设计，后来我发现还是有很多缺点的，比如说 实际索引结构内存占用也不小，而且只有hash索引和entity列索引，那么其他搜索场景，可能依然点需要通过顺序遍历的方式 另外搜索命中entity列索引的ID列表，有可能会分散在各个ID和offset映射的区间，为...","link":"","photos":[],"count_time":{"symbolsCount":"3.7k","symbolsTime":"3 mins."},"categories":[],"tags":[{"name":"Java","slug":"Java","count":5,"path":"api/tags/Java.json"},{"name":"工作","slug":"工作","count":2,"path":"api/tags/工作.json"}],"author":{"name":"李志博的博客","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"分享Java、中间件 等技术与学习笔记。","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}},{"title":"BigDecimal类的四个常见陷阱以及如何避免它们","uid":"2e752d116822fcd8f3fa0fbea2092f6c","slug":"BigDecimal类的四个常见陷阱以及如何避免它们","date":"2022-06-11T02:14:48.000Z","updated":"2022-06-17T08:24:03.804Z","comments":true,"path":"api/articles/BigDecimal类的四个常见陷阱以及如何避免它们.json","keywords":null,"cover":null,"text":"在Java中进行货币计算时，您可以使用java.math.BigDecimal–但要注意该类的一些独特挑战。 在使用Java进行商业计算时，尤其是对于货币，最好使用该类来避免与浮点算术相关的问题，如果使用两个基元类型之一：Float或Double(或它们的盒装类型对应类型)，则可...","link":"","photos":[],"count_time":{"symbolsCount":"4k","symbolsTime":"4 mins."},"categories":[],"tags":[{"name":"Java","slug":"Java","count":5,"path":"api/tags/Java.json"}],"author":{"name":"李志博的博客","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"分享Java、中间件 等技术与学习笔记。","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}},{"title":"SpringBoot单测通过注解覆盖Spring配置","uid":"725e856f26b6befd144f449656c3dc6b","slug":"SpringBoot单测通过注解覆盖Spring配置","date":"2022-06-05T06:58:09.000Z","updated":"2022-06-17T08:24:56.933Z","comments":true,"path":"api/articles/SpringBoot单测通过注解覆盖Spring配置.json","keywords":null,"cover":null,"text":"在我们写SpringBoot的单测的时候,有时候可能需要指定特殊的配置,用来覆盖原有的配置，以前的做法通常是2种 在IDEA的RUN&#x2F;DEBUG Configurations 弹窗上设置-D启动参数 在单测上人工写1个static 代码块，然后里面写System.set...","link":"","photos":[],"count_time":{"symbolsCount":"1.1k","symbolsTime":"1 mins."},"categories":[],"tags":[{"name":"Spring","slug":"Spring","count":2,"path":"api/tags/Spring.json"},{"name":"SpringBoot","slug":"SpringBoot","count":2,"path":"api/tags/SpringBoot.json"}],"author":{"name":"李志博的博客","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"分享Java、中间件 等技术与学习笔记。","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}},{"title":"文件缓存的设计","uid":"2d0169f6f2111380cc34e7095654794f","slug":"文件缓存的设计","date":"2022-06-05T06:55:29.000Z","updated":"2022-06-18T03:24:16.145Z","comments":true,"path":"api/articles/文件缓存的设计.json","keywords":null,"cover":[],"text":"背景最近工作中需要做1个很有意思并且有一定挑战的事情，项目里有1个接口，如果是第一次查询，会一次性查整个表的所有数据，然后缓存在JVM内部，后续的搜索就都会查这个缓存，这个方案肯定是不合理的，但是未来也是有计划迁移到另外1个替代它的项目上，但是在迁移之前，领导叫我临时性的做下内存...","link":"","photos":[],"count_time":{"symbolsCount":"5.7k","symbolsTime":"5 mins."},"categories":[],"tags":[{"name":"Java","slug":"Java","count":5,"path":"api/tags/Java.json"},{"name":"工作","slug":"工作","count":2,"path":"api/tags/工作.json"}],"author":{"name":"李志博的博客","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"分享Java、中间件 等技术与学习笔记。","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}},{"title":"Mockito跟SpringBoot@Autowired组合使用方式","uid":"9f14b7d15ba15e4a4bdd3158410a83f4","slug":"Mockito跟SpringBoot-Autowired组合使用方式","date":"2022-06-04T06:10:53.000Z","updated":"2022-06-05T01:52:56.700Z","comments":true,"path":"api/articles/Mockito跟SpringBoot-Autowired组合使用方式.json","keywords":null,"cover":null,"text":"有的时候，我们想绝大多数Bean在单测的时候，还是希望走正常的Bean注入,只有少部分Bean需要自己人工Mock结果，这个时候如何优雅的Mock Bean实例并自动和其他Bean实例一样进行注入呢？ 可以通过Mockito的@MockBean注解解决，代码如下 @SpringB...","link":"","photos":[],"count_time":{"symbolsCount":396,"symbolsTime":"1 mins."},"categories":[],"tags":[{"name":"mockito","slug":"mockito","count":1,"path":"api/tags/mockito.json"},{"name":"SpringBoot","slug":"SpringBoot","count":2,"path":"api/tags/SpringBoot.json"}],"author":{"name":"李志博的博客","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"分享Java、中间件 等技术与学习笔记。","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}},{"title":"Eclipse-Collection之IntIntHashMap","uid":"e939d2a67c854d9584266b38aea34ab3","slug":"Eclipse-Collection之IntIntHashMap","date":"2022-05-23T14:09:07.000Z","updated":"2022-05-23T14:21:20.966Z","comments":true,"path":"api/articles/Eclipse-Collection之IntIntHashMap.json","keywords":null,"cover":[],"text":"最近在设计1个功能，其中需要内存保存数据的全量索引，结构大概如下: Map&lt;Integer,Integer&gt; indexMap &#x3D; new HashMap&lt;&gt;(); 我跑单测观察这个Map占用内存的时候发现，110多万的数据要消耗500多MB内存...","link":"","photos":[],"count_time":{"symbolsCount":"1.3k","symbolsTime":"1 mins."},"categories":[],"tags":[{"name":"Java","slug":"Java","count":5,"path":"api/tags/Java.json"},{"name":"Eclipse-Collection","slug":"Eclipse-Collection","count":1,"path":"api/tags/Eclipse-Collection.json"}],"author":{"name":"李志博的博客","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"分享Java、中间件 等技术与学习笔记。","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}},{"title":"native内存最佳实践","uid":"f929186e789271318e9dfdac1fb85b07","slug":"native内存最佳实践","date":"2022-05-21T01:43:03.000Z","updated":"2022-05-21T08:57:15.547Z","comments":true,"path":"api/articles/native内存最佳实践.json","keywords":null,"cover":[],"text":"堆是Java应用程序中最大的内存消耗者，但JVM将分配和使用大量本机内存。虽然第7章从编程的角度讨论了有效管理堆的方法，但堆的配置以及它如何与操作系统的本机内存交互是影响应用程序整体性能的另一个重要因素。这里存在术语冲突，因为C程序员倾向于将其本机内存的一部分称为C堆。为了与以J...","link":"","photos":[],"count_time":{"symbolsCount":"15k","symbolsTime":"14 mins."},"categories":[],"tags":[{"name":"Java","slug":"Java","count":5,"path":"api/tags/Java.json"},{"name":"JVM","slug":"JVM","count":2,"path":"api/tags/JVM.json"}],"author":{"name":"李志博的博客","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"分享Java、中间件 等技术与学习笔记。","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}},{"title":"高级文件IO","uid":"56a9693faf1b310ae2faaa7452bad4b8","slug":"高级文件IO","date":"2022-05-15T14:50:22.000Z","updated":"2022-05-17T15:24:40.530Z","comments":true,"path":"api/articles/高级文件IO.json","keywords":null,"cover":[],"text":"通常，人们会对CPU及其性能感到紧张。虽然很重要，但在许多实际应用程序工作负载中，拖累性能的不是CPU，而是I&#x2F;O代码路径。这是完全可以理解的；回想一下，在第2章-虚拟内存中，我们展示了与RAM相比，磁盘速度慢了几个数量级。这种情况与网络I&#x2F;O类似；因此，由于...","link":"","photos":[],"count_time":{"symbolsCount":"15k","symbolsTime":"13 mins."},"categories":[],"tags":[{"name":"linux","slug":"linux","count":1,"path":"api/tags/linux.json"},{"name":"IO","slug":"IO","count":1,"path":"api/tags/IO.json"}],"author":{"name":"李志博的博客","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"分享Java、中间件 等技术与学习笔记。","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}},{"title":"RocketMQ-NameServer的源码阅读脉络","uid":"7a8ccfb903ca33a7195e4b4486061453","slug":"RocketMQ-NameServer的源码阅读脉络","date":"2022-05-15T04:00:02.000Z","updated":"2022-06-17T08:24:39.086Z","comments":true,"path":"api/articles/RocketMQ-NameServer的源码阅读脉络.json","keywords":null,"cover":null,"text":"启动大概流程 NamesrvStartup 是启动类，会先调createNamesrvController 初始化配置，然后创建NamesrvController, 然后调Controller的静态start方法 NamesrvController的静态Start方法会先调ini...","link":"","photos":[],"count_time":{"symbolsCount":739,"symbolsTime":"1 mins."},"categories":[],"tags":[{"name":"RocketMQ","slug":"RocketMQ","count":1,"path":"api/tags/RocketMQ.json"}],"author":{"name":"李志博的博客","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"分享Java、中间件 等技术与学习笔记。","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}},{"title":"Maven多模块统一管理版本","uid":"957c5556bfb48cc069f3d5abcb598019","slug":"Maven多模块统一管理版本","date":"2022-05-14T05:27:00.000Z","updated":"2022-06-17T08:24:15.660Z","comments":true,"path":"api/articles/Maven多模块统一管理版本.json","keywords":null,"cover":null,"text":"之前写多模块项目的时候，一般都需要保证各模块的版本号是一致的，所以导致每次代码有变动需要升级版本的时候，都需要全局挨个替换，但是这种方式太麻烦，也不够优雅，由于最近工作是维护公司的apollo，所以我看了下apollo的pom文件里的方式，觉得还不错。 首先是要在多模块项目里的父...","link":"","photos":[],"count_time":{"symbolsCount":"1k","symbolsTime":"1 mins."},"categories":[],"tags":[{"name":"maven","slug":"maven","count":1,"path":"api/tags/maven.json"}],"author":{"name":"李志博的博客","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"分享Java、中间件 等技术与学习笔记。","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}},{"title":"MySQL查询Value区分大小写","uid":"472d9f1a708133ccb720a7af7f9b0d65","slug":"MySQL查询Value区分大小写","date":"2022-05-14T02:23:27.000Z","updated":"2022-06-17T08:24:25.411Z","comments":true,"path":"api/articles/MySQL查询Value区分大小写.json","keywords":null,"cover":[],"text":"今天1个同事问我1个问题，MySQL查询如何区分大小写，当时我就惊了，难道默认不区分吗？于是我做了一下尝试，在本地建了1个表，发现还真的不区分，效果如下: 然后我执行下面的SQL发现居然可以把zhangsan 查的到 select * from student where nam...","link":"","photos":[],"count_time":{"symbolsCount":302,"symbolsTime":"1 mins."},"categories":[],"tags":[{"name":"mysql","slug":"mysql","count":2,"path":"api/tags/mysql.json"}],"author":{"name":"李志博的博客","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"分享Java、中间件 等技术与学习笔记。","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}}],"categories":0,"tags":0,"word_count":"64k","post_count":22}